
var Module = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  
  return (
function(Module) {
  Module = Module || {};

var Module = typeof Module != "undefined" ? Module : {};

var readyPromiseResolve, readyPromiseReject;

Module["ready"] = new Promise(function(resolve, reject) {
 readyPromiseResolve = resolve;
 readyPromiseReject = reject;
});

var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];

var thisProgram = "./this.program";

var quit_ = (status, toThrow) => {
 throw toThrow;
};

var ENVIRONMENT_IS_WEB = true;

var ENVIRONMENT_IS_WORKER = false;

var scriptDirectory = "";

function locateFile(path) {
 if (Module["locateFile"]) {
  return Module["locateFile"](path, scriptDirectory);
 }
 return scriptDirectory + path;
}

var read_, readAsync, readBinary, setWindowTitle;

if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
 if (ENVIRONMENT_IS_WORKER) {
  scriptDirectory = self.location.href;
 } else if (typeof document != "undefined" && document.currentScript) {
  scriptDirectory = document.currentScript.src;
 }
 if (_scriptDir) {
  scriptDirectory = _scriptDir;
 }
 if (scriptDirectory.indexOf("blob:") !== 0) {
  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
 } else {
  scriptDirectory = "";
 }
 {
  read_ = url => {
   try {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, false);
    xhr.send(null);
    return xhr.responseText;
   } catch (err) {
    var data = tryParseAsDataURI(url);
    if (data) {
     return intArrayToString(data);
    }
    throw err;
   }
  };
  if (ENVIRONMENT_IS_WORKER) {
   readBinary = url => {
    try {
     var xhr = new XMLHttpRequest();
     xhr.open("GET", url, false);
     xhr.responseType = "arraybuffer";
     xhr.send(null);
     return new Uint8Array(xhr.response);
    } catch (err) {
     var data = tryParseAsDataURI(url);
     if (data) {
      return data;
     }
     throw err;
    }
   };
  }
  readAsync = (url, onload, onerror) => {
   var xhr = new XMLHttpRequest();
   xhr.open("GET", url, true);
   xhr.responseType = "arraybuffer";
   xhr.onload = () => {
    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
     onload(xhr.response);
     return;
    }
    var data = tryParseAsDataURI(url);
    if (data) {
     onload(data.buffer);
     return;
    }
    onerror();
   };
   xhr.onerror = onerror;
   xhr.send(null);
  };
 }
 setWindowTitle = title => document.title = title;
} else {}

var out = Module["print"] || console.log.bind(console);

var err = Module["printErr"] || console.warn.bind(console);

Object.assign(Module, moduleOverrides);

moduleOverrides = null;

if (Module["arguments"]) arguments_ = Module["arguments"];

if (Module["thisProgram"]) thisProgram = Module["thisProgram"];

if (Module["quit"]) quit_ = Module["quit"];

var wasmBinary;

if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];

var noExitRuntime = Module["noExitRuntime"] || true;

if (typeof WebAssembly != "object") {
 abort("no native wasm support detected");
}

var wasmMemory;

var ABORT = false;

var EXITSTATUS;

function assert(condition, text) {
 if (!condition) {
  abort(text);
 }
}

var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;

function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
 var endIdx = idx + maxBytesToRead;
 var endPtr = idx;
 while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
 if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
  return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
 }
 var str = "";
 while (idx < endPtr) {
  var u0 = heapOrArray[idx++];
  if (!(u0 & 128)) {
   str += String.fromCharCode(u0);
   continue;
  }
  var u1 = heapOrArray[idx++] & 63;
  if ((u0 & 224) == 192) {
   str += String.fromCharCode((u0 & 31) << 6 | u1);
   continue;
  }
  var u2 = heapOrArray[idx++] & 63;
  if ((u0 & 240) == 224) {
   u0 = (u0 & 15) << 12 | u1 << 6 | u2;
  } else {
   u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
  }
  if (u0 < 65536) {
   str += String.fromCharCode(u0);
  } else {
   var ch = u0 - 65536;
   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
  }
 }
 return str;
}

function UTF8ToString(ptr, maxBytesToRead) {
 return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
}

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
 if (!(maxBytesToWrite > 0)) return 0;
 var startIdx = outIdx;
 var endIdx = outIdx + maxBytesToWrite - 1;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) {
   var u1 = str.charCodeAt(++i);
   u = 65536 + ((u & 1023) << 10) | u1 & 1023;
  }
  if (u <= 127) {
   if (outIdx >= endIdx) break;
   heap[outIdx++] = u;
  } else if (u <= 2047) {
   if (outIdx + 1 >= endIdx) break;
   heap[outIdx++] = 192 | u >> 6;
   heap[outIdx++] = 128 | u & 63;
  } else if (u <= 65535) {
   if (outIdx + 2 >= endIdx) break;
   heap[outIdx++] = 224 | u >> 12;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  } else {
   if (outIdx + 3 >= endIdx) break;
   heap[outIdx++] = 240 | u >> 18;
   heap[outIdx++] = 128 | u >> 12 & 63;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  }
 }
 heap[outIdx] = 0;
 return outIdx - startIdx;
}

function stringToUTF8(str, outPtr, maxBytesToWrite) {
 return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}

function lengthBytesUTF8(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var c = str.charCodeAt(i);
  if (c <= 127) {
   len++;
  } else if (c <= 2047) {
   len += 2;
  } else if (c >= 55296 && c <= 57343) {
   len += 4;
   ++i;
  } else {
   len += 3;
  }
 }
 return len;
}

var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBufferAndViews(buf) {
 buffer = buf;
 Module["HEAP8"] = HEAP8 = new Int8Array(buf);
 Module["HEAP16"] = HEAP16 = new Int16Array(buf);
 Module["HEAP32"] = HEAP32 = new Int32Array(buf);
 Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
 Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
 Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
 Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
 Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
}

var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;

var wasmTable;

var __ATPRERUN__ = [];

var __ATINIT__ = [];

var __ATPOSTRUN__ = [];

var runtimeInitialized = false;

function preRun() {
 if (Module["preRun"]) {
  if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
  while (Module["preRun"].length) {
   addOnPreRun(Module["preRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
 runtimeInitialized = true;
 callRuntimeCallbacks(__ATINIT__);
}

function postRun() {
 if (Module["postRun"]) {
  if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
  while (Module["postRun"].length) {
   addOnPostRun(Module["postRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
 __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
 __ATINIT__.unshift(cb);
}

function addOnPostRun(cb) {
 __ATPOSTRUN__.unshift(cb);
}

var runDependencies = 0;

var runDependencyWatcher = null;

var dependenciesFulfilled = null;

function addRunDependency(id) {
 runDependencies++;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
}

function removeRunDependency(id) {
 runDependencies--;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
 if (runDependencies == 0) {
  if (runDependencyWatcher !== null) {
   clearInterval(runDependencyWatcher);
   runDependencyWatcher = null;
  }
  if (dependenciesFulfilled) {
   var callback = dependenciesFulfilled;
   dependenciesFulfilled = null;
   callback();
  }
 }
}

function abort(what) {
 {
  if (Module["onAbort"]) {
   Module["onAbort"](what);
  }
 }
 what = "Aborted(" + what + ")";
 err(what);
 ABORT = true;
 EXITSTATUS = 1;
 what += ". Build with -sASSERTIONS for more info.";
 var e = new WebAssembly.RuntimeError(what);
 readyPromiseReject(e);
 throw e;
}

var dataURIPrefix = "data:application/octet-stream;base64,";

function isDataURI(filename) {
 return filename.startsWith(dataURIPrefix);
}

var wasmBinaryFile;

wasmBinaryFile = "data:application/octet-stream;base64,AGFzbQEAAAABvwEcYAF/AX9gAX8AYAJ/fwF/YAN/f38AYAN/f38Bf2ACf38AYAR/f39/AX9gBH9/f38AYAJ/fABgAABgBH9/f38BfGAFf39/f38AYAZ/f39/f38AYAV/f39/fwF/YAd/f39/f39/AGABfwF9YAABf2AIf39/f39/f38AYA1/f39/f39/f39/f39/AGACfH8BfGABfAF8YAN8fH8BfGACfHwBfGABfwF8YAR/f35+AGACfH8Bf2ADf398AGACf38BfQJzEwFhAWEABwFhAWIAAwFhAWMAEQFhAWQACwFhAWUAAwFhAWYAAAFhAWcAAAFhAWgAAwFhAWkABQFhAWoAAwFhAWsADAFhAWwAEgFhAW0ADgFhAW4AAwFhAW8ACQFhAXAABQFhAXEABQFhAXIADgFhAXMACwOWAZQBAQAEBQICBAECAwETABQVFgkBAAsBCgAXAAABAAABBQEFAQAAAwEYBwIECQkJGQIHAwEBAQAAAQAAAAQIBQABAgICAwMDAwEKCgABAgQDAAEBCAMAAQYGBgEAAAEHBg0GAAECBAUDAAAAAQICBAAAAAIBGgUGDRsACQkACwwHBAQLDAcEAAgICAgDBBAAAQACAw8GAgQFAXABfn4FBwEBgAKAgAIGCQF/AUHg5cACCwclCAF0AgABdQCMAQF2AI0BAXcAiwEBeAApAXkBAAF6ABMBQQCXAQmmAQEAQQELfT4/R0U8ogGKAZ4BnwE7mgGFAZsBmAGZAaEBO50BhwGgAYYBnAE6SEY8pgGjATqkAYkBpQGIASwlLj02hAFzdHl4dnV6e3x9d3BycW1ub2poaSUaTU5PbGs1Y4ABZX9+gQFmZ4MBZFxdYF9eggFiYVBRVVknWltUU1JWWFclGicnkgEakQEaTBpLLS9JLy0algGUAZMBlQEajwGOAZABGkoK+coClAHKDAEHfwJAIABFDQAgAEEIayICIABBBGsoAgAiAUF4cSIAaiEFAkAgAUEBcQ0AIAFBA3FFDQEgAiACKAIAIgFrIgJB9OEAKAIASQ0BIAAgAWohAEH44QAoAgAgAkcEQCABQf8BTQRAIAIoAggiBCABQQN2IgFBA3RBjOIAakYaIAQgAigCDCIDRgRAQeThAEHk4QAoAgBBfiABd3E2AgAMAwsgBCADNgIMIAMgBDYCCAwCCyACKAIYIQYCQCACIAIoAgwiAUcEQCACKAIIIgMgATYCDCABIAM2AggMAQsCQCACQRRqIgQoAgAiAw0AIAJBEGoiBCgCACIDDQBBACEBDAELA0AgBCEHIAMiAUEUaiIEKAIAIgMNACABQRBqIQQgASgCECIDDQALIAdBADYCAAsgBkUNAQJAIAIoAhwiBEECdEGU5ABqIgMoAgAgAkYEQCADIAE2AgAgAQ0BQejhAEHo4QAoAgBBfiAEd3E2AgAMAwsgBkEQQRQgBigCECACRhtqIAE2AgAgAUUNAgsgASAGNgIYIAIoAhAiAwRAIAEgAzYCECADIAE2AhgLIAIoAhQiA0UNASABIAM2AhQgAyABNgIYDAELIAUoAgQiAUEDcUEDRw0AQezhACAANgIAIAUgAUF+cTYCBCACIABBAXI2AgQgACACaiAANgIADwsgAiAFTw0AIAUoAgQiAUEBcUUNAAJAIAFBAnFFBEBB/OEAKAIAIAVGBEBB/OEAIAI2AgBB8OEAQfDhACgCACAAaiIANgIAIAIgAEEBcjYCBCACQfjhACgCAEcNA0Hs4QBBADYCAEH44QBBADYCAA8LQfjhACgCACAFRgRAQfjhACACNgIAQezhAEHs4QAoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAAkAgAUH/AU0EQCAFKAIIIgQgAUEDdiIBQQN0QYziAGpGGiAEIAUoAgwiA0YEQEHk4QBB5OEAKAIAQX4gAXdxNgIADAILIAQgAzYCDCADIAQ2AggMAQsgBSgCGCEGAkAgBSAFKAIMIgFHBEAgBSgCCCIDQfThACgCAEkaIAMgATYCDCABIAM2AggMAQsCQCAFQRRqIgQoAgAiAw0AIAVBEGoiBCgCACIDDQBBACEBDAELA0AgBCEHIAMiAUEUaiIEKAIAIgMNACABQRBqIQQgASgCECIDDQALIAdBADYCAAsgBkUNAAJAIAUoAhwiBEECdEGU5ABqIgMoAgAgBUYEQCADIAE2AgAgAQ0BQejhAEHo4QAoAgBBfiAEd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAE2AgAgAUUNAQsgASAGNgIYIAUoAhAiAwRAIAEgAzYCECADIAE2AhgLIAUoAhQiA0UNACABIAM2AhQgAyABNgIYCyACIABBAXI2AgQgACACaiAANgIAIAJB+OEAKAIARw0BQezhACAANgIADwsgBSABQX5xNgIEIAIgAEEBcjYCBCAAIAJqIAA2AgALIABB/wFNBEAgAEF4cUGM4gBqIQECf0Hk4QAoAgAiA0EBIABBA3Z0IgBxRQRAQeThACAAIANyNgIAIAEMAQsgASgCCAshACABIAI2AgggACACNgIMIAIgATYCDCACIAA2AggPC0EfIQQgAEH///8HTQRAIABBCHYiASABQYD+P2pBEHZBCHEiBHQiASABQYDgH2pBEHZBBHEiA3QiASABQYCAD2pBEHZBAnEiAXRBD3YgAyAEciABcmsiAUEBdCAAIAFBFWp2QQFxckEcaiEECyACIAQ2AhwgAkIANwIQIARBAnRBlOQAaiEHAkACQAJAQejhACgCACIDQQEgBHQiAXFFBEBB6OEAIAEgA3I2AgAgByACNgIAIAIgBzYCGAwBCyAAQRkgBEEBdmtBACAEQR9HG3QhBCAHKAIAIQEDQCABIgMoAgRBeHEgAEYNAiAEQR12IQEgBEEBdCEEIAMgAUEEcWoiB0EQaigCACIBDQALIAcgAjYCECACIAM2AhgLIAIgAjYCDCACIAI2AggMAQsgAygCCCIAIAI2AgwgAyACNgIIIAJBADYCGCACIAM2AgwgAiAANgIIC0GE4gBBhOIAKAIAQQFrIgBBfyAAGzYCAAsLGwAgAEEBIAAbIQACQCAAECkiAA0AEA4ACyAAC3QBAX8gAkUEQCAAKAIEIAEoAgRGDwsgACABRgRAQQEPCyABKAIEIgItAAAhAQJAIAAoAgQiAy0AACIARQ0AIAAgAUcNAANAIAItAAEhASADLQABIgBFDQEgAkEBaiECIANBAWohAyAAIAFGDQALCyAAIAFGC84BAQJ/AkACfyABIAAoAgwgACgCFCICQQJ0bksEQCAAIAEgAmxBAnRB/x9qQYBgcSIBNgIMIAFBEHIQFCICQQ9qQXBxIQEgACgCEARAIAEgACAAKAIAKAIIEQAAIAAoAhAgACgCFGxBAnQQGRoLIAAoAggiAwRAIAMQEwsgACACNgIIIAAgATYCBCAAQRhqDAELIAAoAgQiAUUNASAAKAIYRQ0BIAEgACAAKAIAKAIIEQAAIAAoAhQgACgCEGxBAnQQHCAAQRhqC0EANgIACwvYAgECfwJAIAFFDQAgAEEAOgAAIAAgAWoiAkEBa0EAOgAAIAFBA0kNACAAQQA6AAIgAEEAOgABIAJBA2tBADoAACACQQJrQQA6AAAgAUEHSQ0AIABBADoAAyACQQRrQQA6AAAgAUEJSQ0AIABBACAAa0EDcSIDaiICQQA2AgAgAiABIANrQXxxIgNqIgFBBGtBADYCACADQQlJDQAgAkEANgIIIAJBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIANBGUkNACACQQA2AhggAkEANgIUIAJBADYCECACQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAMgAkEEcUEYciIDayIBQSBJDQAgAiADaiECA0AgAkIANwMYIAJCADcDECACQgA3AwggAkIANwMAIAJBIGohAiABQSBrIgFBH0sNAAsLIAALugIBBH8jAEFAaiICJAAgACgCACIDQQRrKAIAIQQgA0EIaygCACEFIAJCADcCHCACQgA3AiQgAkIANwIsIAJCADcCNEEAIQMgAkEANgA7IAJCADcCFCACQZzDADYCECACIAA2AgwgAiABNgIIIAAgBWohAAJAIAQgAUEAEBUEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEMACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBELAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADC4AEAQN/IAJBgARPBEAgACABIAIQDSAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIABBA3FFBEAgACECDAELIAJFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICQQNxRQ0BIAIgA0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCAC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IAEgA0ECdCAEQQJ0QWBxaxAXGiAHCyMBAX8gAEGENzYCACAAKAIIIgEEQCABEBMLIABCADcCBCAACx4BAX8gAEGENzYCACAAKAIIIgEEQCABEBMLIAAQEws0AQF/IAEgACgCECICTwRAIABBADYCECACDwsgACACIAFrNgIQIAAgACgCGCABajYCGCABC0EBAX8gACgCECEDIAEgACAAKAIAKAIIEQAAIAMgAiACIANLGyIBIAAoAhRsQQJ0EBkaIAAgASAAKAIAKAIUEQIACxsAIAAgACgCECABahAWIAAgACgCECABajYCEAtAAQF/IAAgACgCECACahAWIAAoAgQgACgCFCIDIAAoAhBsQQJ0aiABIAIgA2xBAnQQGRogACAAKAIQIAJqNgIQCy8BAX8gACgCBCIBRQRAQbQbQekeQZYBQYckEAAACyABIAAoAhQgACgCGGxBAnRqCwcAIAAoAhALCAAgACgCEEULEAAgAEEANgIYIABBADYCEAsdAQF/IAEgACgCECICSQR/IAAgATYCECABBSACCwsWACAAKAIEIgAgASAAKAIAKAIUEQIACxgAIAAoAgQiACABIAIgACgCACgCEBEEAAsUACAAKAIEIgAgACgCACgCCBEAAAsUACAAKAIEIgAgACgCACgCGBEAAAsUACAAKAIEIgAgACgCACgCHBEAAAsWACAAKAIEIgAgASAAKAIAKAIkEQIACwgAIAAQNhATCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRCAALNQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRAQALOQEBfyABIAAoAgQiBEEBdWohASAAKAIAIQAgASACIAMgBEEBcQR/IAEoAgAgAGooAgAFIAALEQQACzsBAX8gASAAKAIEIgVBAXVqIQEgACgCACEAIAEgAiADIAQgBUEBcQR/IAEoAgAgAGooAgAFIAALEQYACzUBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAIAEgAkEBcQR/IAEoAgAgAGooAgAFIAALEQ8ACwcAIAAREAALJAEBf0HU4QAoAgAiAARAA0AgACgCABEJACAAKAIEIgANAAsLC4kBAEHE4QBBATYCAEHI4QBB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kYK8mIPJFuNg7z+sksHVUFqOPIUy2wPmae8/S2sBrFk6hDxgtAHzIXPvPx8+tAch1YK8X5t7M5d87z/JDUc7uSqJvCmh9RRGhu8/04g6YAS2dDz2P4vnLpDvP3FynVHsxYM8g0zH+1Ga7z/wkdOPEvePvNqQpKKvpO8/fXQj4piujbzxZ44tSK/vPwggqkG8w448J1ph7hu67z8y66nDlCuEPJe6azcrxe8/7oXRMalkijxARW5bdtDvP+3jO+S6N468FL6crf3b7z+dzZFNO4l3PNiQnoHB5+8/icxgQcEFUzzxcY8rwvPvP3Vuc2lnbmVkIHNob3J0AHdpbmRvd0xlbiA+IHdpbmRvd1N0YXJ0AGdldENoYW5uZWxDb3VudAB1bnNpZ25lZCBpbnQAQlBNRGV0ZWN0AGZsb2F0AHVpbnQ2NF90AHNldENvZWZmaWNpZW50cwBnZXRCZWF0cwBncDEgPT0gcGVha3BvcwB1cGRhdGVCZWF0UG9zAEVycm9yOiBJbGxlZ2FsIG51bWJlciBvZiBjaGFubmVscwBjYWxjdWxhdGVDb2VmZnMAc2V0UGl0Y2hTZW1pVG9uZXMAaW5wdXRTYW1wbGVzAHByb2Nlc3NTYW1wbGVzAHVwZGF0ZVhDb3JyAHZlY3RvcgBCUE1EZXRlY3RvcgBnZXRQZWFrQ2VudGVyAHBBQUZpbHRlcgBvdXRwdXQgPT0gcFJhdGVUcmFuc3Bvc2VyAGJ1ZmZlcgB1bnNpZ25lZCBjaGFyAC9Vc2Vycy90b2JpYXMvRGV2ZWxvcGVyL2JlY2hzdGVpbi9zb3VuZHN0cmV0Y2gtd2ViL3dhc20vbGliL3NvdW5kdG91Y2gvc291cmNlL1NvdW5kVG91Y2gvQlBNRGV0ZWN0LmNwcAAvVXNlcnMvdG9iaWFzL0RldmVsb3Blci9iZWNoc3RlaW4vc291bmRzdHJldGNoLXdlYi93YXNtL2xpYi9zb3VuZHRvdWNoL3NvdXJjZS9Tb3VuZFRvdWNoL0ZJUkZpbHRlci5jcHAAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9zb3VyY2UvU291bmRUb3VjaC9BQUZpbHRlci5jcHAAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9zb3VyY2UvU291bmRUb3VjaC9SYXRlVHJhbnNwb3Nlci5jcHAAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9zb3VyY2UvU291bmRUb3VjaC9GSUZPU2FtcGxlQnVmZmVyLmNwcAAvVXNlcnMvdG9iaWFzL0RldmVsb3Blci9iZWNoc3RlaW4vc291bmRzdHJldGNoLXdlYi93YXNtL2xpYi9zb3VuZHRvdWNoL3NvdXJjZS9Tb3VuZFRvdWNoL1BlYWtGaW5kZXIuY3BwAC9Vc2Vycy90b2JpYXMvRGV2ZWxvcGVyL2JlY2hzdGVpbi9zb3VuZHN0cmV0Y2gtd2ViL3dhc20vbGliL3NvdW5kdG91Y2gvc291cmNlL1NvdW5kVG91Y2gvU291bmRUb3VjaC5jcHAAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9zb3VyY2UvU291bmRUb3VjaC9URFN0cmV0Y2guY3BwAC9Vc2Vycy90b2JpYXMvRGV2ZWxvcGVyL2JlY2hzdGVpbi9zb3VuZHN0cmV0Y2gtd2ViL3dhc20vbGliL3NvdW5kdG91Y2gvc291cmNlL1NvdW5kVG91Y2gvSW50ZXJwb2xhdGVDdWJpYy5jcHAAb3ZlcmxhcABzZXRUZW1wbwBjYWxjRWZmZWN0aXZlUmF0ZUFuZFRlbXBvAGV2YWx1YXRlRmlsdGVyTW9ubwB0cmFuc3Bvc2VNb25vAGV2YWx1YXRlRmlsdGVyU3RlcmVvAHRyYW5zcG9zZVN0ZXJlbwBzdGQ6OmV4Y2VwdGlvbgBnZXRWZXJzaW9uAHB0ckJlZ2luAGdldEJwbQBib29sAHB1bGwAcGVha2xldmVsID49IGxldmVsAGZpbmRDcm9zc2luZ0xldmVsAGVtc2NyaXB0ZW46OnZhbABldmFsdWF0ZUZpbHRlck11bHRpAHRyYW5zcG9zZU11bHRpAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGxlbmd0aERpdjggKiA4ID09IGxlbmd0aABsZW5ndGggPT0gbmV3TGVuZ3RoAGNhbGN1bGF0ZU92ZXJsYXBMZW5ndGgAcHVzaABmbHVzaABzZXRQaXRjaABTb3VuZFN0cmV0Y2gAb3V0cHV0ID09IHBURFN0cmV0Y2gAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9pbmNsdWRlL0ZJRk9TYW1wbGVQaXBlLmgAdW5zaWduZWQgbG9uZwBzdGQ6OndzdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAZXZhbHVhdGUAVG9vIHNtYWxsIHNhbXBsZXJhdGUARXJyb3I6IEV4Y2Vzc2l2ZSBzYW1wbGVyYXRlAGRlY2ltYXRlAHNldFJhdGUAdHJhbnNwb3NlAHNldE91dFBpcGUAZG91YmxlAGF2YWlsYWJsZQB2b2lkAFNvdW5kVG91Y2ggOiBOdW1iZXIgb2YgY2hhbm5lbHMgbm90IGRlZmluZWQAU291bmRUb3VjaCA6IFNhbXBsZSByYXRlIG5vdCBkZWZpbmVkAHN0ZDo6YmFkX2FsbG9jAG91dHB1dCA9PSBOVUxMAGRlc3QgIT0gTlVMTABmaWx0ZXJDb2VmZnMgIT0gTlVMTABzcmMgIT0gTlVMTABlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AEZJUiBmaWx0ZXIgbGVuZ3RoIG5vdCBkaXZpc2libGUgYnkgOAB0ZW1wID49IC0zMjc2OCAmJiB0ZW1wIDw9IDMyNzY3AG51bUNoYW5uZWxzIDwgMTYAd29ya1tsZW5ndGgvMiAtIDFdID4gLTFlLTYAd29ya1tsZW5ndGgvMiArIDFdID4gLTFlLTYAY3V0b2ZmRnJlcSA8PSAwLjUAbGVuZ3RoID49IDIAZnJhY3QgPCAxLjAAZGVjaW1hdGVCeSA+IDAAY2hhbm5lbHMgPiAwAG51bUNoYW5uZWxzID4gMABzdW0gPiAwAGxlbmd0aCA+IDAAbmV3TGVuZ3RoID4gMAB3b3JrW2xlbmd0aC8yXSA+IDAAY3V0b2ZmRnJlcSA+PSAwAG92ZXJsYXBJbk1zZWMgPj0gMABsZW5ndGggJSA0ID09IDAAZGVjaW1hdGVCeSAhPSAwAGlsZW5ndGggIT0gMABidWZmZXItPm51bVNhbXBsZXMoKSA+PSAodWludCkocHJvY2Vzc19zYW1wbGVzICsgd2luZG93TGVuKQAobGVuZ3RoICE9IDApICYmIChsZW5ndGggPT0gaWxlbmd0aCkgJiYgKHNyYyAhPSBOVUxMKSAmJiAoZGVzdCAhPSBOVUxMKSAmJiAoZmlsdGVyQ29lZmZzICE9IE5VTEwpAG51bUNoYW5uZWxzID09IGRlc3QuZ2V0Q2hhbm5lbHMoKQAob2Zmc2V0ICsgdGVtcCArIG92ZXJsYXBMZW5ndGgpIDw9IChpbnQpaW5wdXRCdWZmZXIubnVtU2FtcGxlcygpADEyU291bmRTdHJldGNoAAAAICUAAIcZAABQMTJTb3VuZFN0cmV0Y2gA9CMAAKAZAAAAAAAAmBkAAFBLMTJTb3VuZFN0cmV0Y2gAAAAA9CMAAMAZAAABAAAAmBkAAGlpAHYAdmkAsBkAAIAjAACAIwAAaWlpaQAAAACAIwAAgCMAALAZAABpaWkA/CIAALAZAACwIwAAdmlpZAAAAACAIwAA1BkAAAAAAACAIwAAsBkAAIAjAACAIwAAaWlpaWkAAAD8IgAAsBkAAHZpaQBB4DQLdvwiAACwGQAAgCMAAIAjAAB2aWlpaQAxMUJQTURldGVjdG9yACAlAAB2GgAAUDExQlBNRGV0ZWN0b3IAAPQjAACMGgAAAAAAAIQaAABQSzExQlBNRGV0ZWN0b3IA9CMAAKwaAAABAAAAhBoAAJwaAABcIwAAXCMAQeA1C5cr/CIAAJwaAACAIwAAXCMAAKQjAACcGgAAZmlpAAAAAABcIwAAnBoAAIAjAACAIwAAXCMAAGlpaWlpaQAAAAAAAHQbAAAmAAAAJwAAAAAAAABhzhk5WGmEP4em8Gt36ZO/Yc4ZOVhphD9F31V3sn//P8kHFfVjA++/TjEwc291bmR0b3VjaDlCUE1EZXRlY3RFAAAAACAlAABYGwAAAAAAANQbAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAAE4xMHNvdW5kdG91Y2gxNkZJRk9TYW1wbGVCdWZmZXJFAAAAAGAlAACwGwAAFB4AAAAAAAAcHAAAMwAAADQAAAA1AAAANgAAADcAAAA4AAAATjEwc291bmR0b3VjaDlGSVJGaWx0ZXJFAAAAACAlAAAAHAAAAAAAAHgcAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAATjEwc291bmR0b3VjaDE2SW50ZXJwb2xhdGVDdWJpY0UAAAAAYCUAAFQcAAAEHQAAAAAAANgcAABDAAAARAAAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAAE4xMHNvdW5kdG91Y2gxNFJhdGVUcmFuc3Bvc2VyRQAAYCUAALgcAAAcHgAATjEwc291bmR0b3VjaDE0VHJhbnNwb3NlckJhc2VFAAAgJQAA5BwAAAAAAABcHQAATgAAAE8AAABFAAAAUAAAAFEAAABSAAAASQAAAFMAAABUAAAATAAAAFUAAABOMTBzb3VuZHRvdWNoMTBTb3VuZFRvdWNoRQAAYCUAAEAdAAAcHgAAAAAAACgeAABWAAAAVwAAAEUAAABYAAAARwAAAEgAAABJAAAAUwAAAFkAAABMAAAAWgAAAFsAAABcAAAAXQAAAF4AAABfAAAAYAAAAGEAAABiAAAATjEwc291bmR0b3VjaDlURFN0cmV0Y2hFAE4xMHNvdW5kdG91Y2gxM0ZJRk9Qcm9jZXNzb3JFAE4xMHNvdW5kdG91Y2gxNEZJRk9TYW1wbGVQaXBlRQAAACAlAADzHQAAYCUAANUdAAAUHgAAYCUAALwdAAAcHgAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAACAlAAA0HgAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAACAlAAB8HgAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAACAlAADEHgAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAAAgJQAADB8AAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAICUAAFgfAABOMTBlbXNjcmlwdGVuM3ZhbEUAACAlAACkHwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAAAgJQAAwB8AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAICUAAOgfAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAACAlAAAQIAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAAgJQAAOCAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAAICUAAGAgAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAACAlAACIIAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAAgJQAAsCAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAAICUAANggAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAACAlAAAAIQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAAAgJQAAKCEAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAAICUAAFAhAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAABgJQAAeCEAAFAlAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAABgJQAAqCEAAJwhAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAABgJQAA2CEAAJwhAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBgJQAACCIAAPwhAABOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UAAAAAYCUAADgiAACcIQAATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAAAAYCUAAGwiAAD8IQAAAAAAAOwiAABjAAAAZAAAAGUAAABmAAAAZwAAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQBgJQAAxCIAAJwhAAB2AAAAsCIAAPgiAABEbgAAsCIAAAQjAABiAAAAsCIAABAjAABjAAAAsCIAABwjAABoAAAAsCIAACgjAABhAAAAsCIAADQjAABzAAAAsCIAAEAjAAB0AAAAsCIAAEwjAABpAAAAsCIAAFgjAABqAAAAsCIAAGQjAABsAAAAsCIAAHAjAABtAAAAsCIAAHwjAAB4AAAAsCIAAIgjAAB5AAAAsCIAAJQjAABmAAAAsCIAAKAjAABkAAAAsCIAAKwjAABOMTBfX2N4eGFiaXYxMjBfX3NpX2NsYXNzX3R5cGVfaW5mb0UAAAAAYCUAALgjAADMIQAAAAAAACwiAABjAAAAaAAAAGUAAABmAAAAaQAAAAAAAABMJAAAIwAAAGoAAABrAAAAAAAAAHQkAAAjAAAAbAAAAG0AAABTdDlleGNlcHRpb24AU3Q5YmFkX2FsbG9jAAAAYCUAAD0kAACAJQAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAGAlAABYJAAATCQAAAAAAAC4JAAAJAAAAG4AAABvAAAAAAAAAAwlAAAiAAAAcAAAAHEAAABTdDExbG9naWNfZXJyb3IAYCUAAKgkAACAJQAAAAAAAOwkAAAkAAAAcgAAAG8AAABTdDEybGVuZ3RoX2Vycm9yAAAAAGAlAADYJAAAuCQAAFN0MTNydW50aW1lX2Vycm9yAAAAYCUAAPgkAACAJQAAAAAAAMwhAABjAAAAcwAAAGUAAABmAAAAdAAAAHUAAAB2AAAAdwAAAFN0OXR5cGVfaW5mbwAAAAAgJQAAQCUAAAAAAADgIwAAYwAAAHgAAABlAAAAZgAAAHQAAAB5AAAAegAAAHsAAAAgJQAAMCQAAAAAAACAJQAAIwAAAHwAAAB9AAAAAAAAAAMAAAAEAAAABAAAAAYAAACD+aIARE5uAPwpFQDRVycA3TT1AGLbwAA8mZUAQZBDAGNR/gC73qsAt2HFADpuJADSTUIASQbgAAnqLgAcktEA6x3+ACmxHADoPqcA9TWCAES7LgCc6YQAtCZwAEF+XwDWkTkAU4M5AJz0OQCLX4QAKPm9APgfOwDe/5cAD5gFABEv7wAKWosAbR9tAM9+NgAJyycARk+3AJ5mPwAt6l8Auid1AOXrxwA9e/EA9zkHAJJSigD7a+oAH7FfAAhdjQAwA1YAe/xGAPCrawAgvM8ANvSaAOOpHQBeYZEACBvmAIWZZQCgFF8AjUBoAIDY/wAnc00ABgYxAMpWFQDJqHMAe+JgAGuMwAAZxEcAzWfDAAno3ABZgyoAi3bEAKYclgBEr90AGVfRAKU+BQAFB/8AM34/AMIy6ACYT94Au30yACY9wwAea+8An/heADUfOgB/8soA8YcdAHyQIQBqJHwA1W76ADAtdwAVO0MAtRTGAMMZnQCtxMIALE1BAAwAXQCGfUYA43EtAJvGmgAzYgAAtNJ8ALSnlwA3VdUA1z72AKMQGABNdvwAZJ0qAHDXqwBjfPgAerBXABcV5wDASVYAO9bZAKeEOAAkI8sA1op3AFpUIwAAH7kA8QobABnO3wCfMf8AZh5qAJlXYQCs+0cAfn/YACJltwAy6IkA5r9gAO/EzQBsNgkAXT/UABbe1wBYO94A3puSANIiKAAohugA4lhNAMbKMgAI4xYA4H3LABfAUADzHacAGOBbAC4TNACDEmIAg0gBAPWOWwCtsH8AHunyAEhKQwAQZ9MAqt3YAK5fQgBqYc4ACiikANOZtAAGpvIAXHd/AKPCgwBhPIgAinN4AK+MWgBv170ALaZjAPS/ywCNge8AJsFnAFXKRQDK2TYAKKjSAMJhjQASyXcABCYUABJGmwDEWcQAyMVEAE2ykQAAF/MA1EOtAClJ5QD91RAAAL78AB6UzABwzu4AEz71AOzxgACz58MAx/goAJMFlADBcT4ALgmzAAtF8wCIEpwAqyB7AC61nwBHksIAezIvAAxVbQByp5AAa+cfADHLlgB5FkoAQXniAPTfiQDolJcA4uaEAJkxlwCI7WsAX182ALv9DgBImrQAZ6RsAHFyQgCNXTIAnxW4ALzlCQCNMSUA93Q5ADAFHAANDAEASwhoACzuWABHqpAAdOcCAL3WJAD3faYAbkhyAJ8W7wCOlKYAtJH2ANFTUQDPCvIAIJgzAPVLfgCyY2gA3T5fAEBdAwCFiX8AVVIpADdkwABt2BAAMkgyAFtMdQBOcdQARVRuAAsJwQAq9WkAFGbVACcHnQBdBFAAtDvbAOp2xQCH+RcASWt9AB0nugCWaSkAxsysAK0UVACQ4moAiNmJACxyUAAEpL4AdweUAPMwcAAA/CcA6nGoAGbCSQBk4D0Al92DAKM/lwBDlP0ADYaMADFB3gCSOZ0A3XCMABe35wAI3zsAFTcrAFyAoABagJMAEBGSAA/o2ABsgK8A2/9LADiQDwBZGHYAYqUVAGHLuwDHibkAEEC9ANLyBABJdScA67b2ANsiuwAKFKoAiSYvAGSDdgAJOzMADpQaAFE6qgAdo8IAr+2uAFwmEgBtwk0ALXqcAMBWlwADP4MACfD2ACtAjABtMZkAObQHAAwgFQDYw1sA9ZLEAMatSwBOyqUApzfNAOapNgCrkpQA3UJoABlj3gB2jO8AaItSAPzbNwCuoasA3xUxAACuoQAM+9oAZE1mAO0FtwApZTAAV1a/AEf/OgBq+bkAdb7zACiT3wCrgDAAZoz2AATLFQD6IgYA2eQdAD2zpABXG48ANs0JAE5C6QATvqQAMyO1APCqGgBPZagA0sGlAAs/DwBbeM0AI/l2AHuLBACJF3IAxqZTAG9u4gDv6wAAm0pYAMTatwCqZroAds/PANECHQCx8S0AjJnBAMOtdwCGSNoA912gAMaA9ACs8C8A3eyaAD9cvADQ3m0AkMcfACrbtgCjJToAAK+aAK1TkwC2VwQAKS20AEuAfgDaB6cAdqoOAHtZoQAWEioA3LctAPrl/QCJ2/4Aib79AOR2bAAGqfwAPoBwAIVuFQD9h/8AKD4HAGFnMwAqGIYATb3qALPnrwCPbW4AlWc5ADG/WwCE10gAMN8WAMctQwAlYTUAyXDOADDLuAC/bP0ApACiAAVs5ABa3aAAIW9HAGIS0gC5XIQAcGFJAGtW4ACZUgEAUFU3AB7VtwAz8cQAE25fAF0w5ACFLqkAHbLDAKEyNgAIt6QA6rHUABb3IQCPaeQAJ/93AAwDgACNQC0AT82gACClmQCzotMAL10KALT5QgAR2ssAfb7QAJvbwQCrF70AyqKBAAhqXAAuVRcAJwBVAH8U8ADhB4YAFAtkAJZBjQCHvt4A2v0qAGsltgB7iTQABfP+ALm/ngBoak8ASiqoAE/EWgAt+LwA11qYAPTHlQANTY0AIDqmAKRXXwAUP7EAgDiVAMwgAQBx3YYAyd62AL9g9QBNZREAAQdrAIywrACywNAAUVVIAB77DgCVcsMAowY7AMBANQAG3HsA4EXMAE4p+gDWysgA6PNBAHxk3gCbZNgA2b4xAKSXwwB3WNQAaePFAPDaEwC6OjwARhhGAFV1XwDSvfUAbpLGAKwuXQAORO0AHD5CAGHEhwAp/ekA59bzACJ8ygBvkTUACODFAP/XjQBuauIAsP3GAJMIwQB8XXQAa62yAM1unQA+cnsAxhFqAPfPqQApc98Atcm6ALcAUQDisg0AdLokAOV9YAB02IoADRUsAIEYDAB+ZpQAASkWAJ96dgD9/b4AVkXvANl+NgDs2RMAi7q5AMSX/AAxqCcA8W7DAJTFNgDYqFYAtKi1AM/MDgASiS0Ab1c0ACxWiQCZzuMA1iC5AGteqgA+KpwAEV/MAP0LSgDh9PsAjjttAOKGLADp1IQA/LSpAO/u0QAuNckALzlhADghRAAb2cgAgfwKAPtKagAvHNgAU7SEAE6ZjABUIswAKlXcAMDG1gALGZYAGnC4AGmVZAAmWmAAP1LuAH8RDwD0tREA/Mv1ADS8LQA0vO4A6F3MAN1eYABnjpsAkjPvAMkXuABhWJsA4Ve8AFGDxgDYPhAA3XFIAC0c3QCvGKEAISxGAFnz1wDZepgAnlTAAE+G+gBWBvwA5XmuAIkiNgA4rSIAZ5PcAFXoqgCCJjgAyuebAFENpACZM7EAqdcOAGkFSABlsvAAf4inAIhMlwD50TYAIZKzAHuCSgCYzyEAQJ/cANxHVQDhdDoAZ+tCAP6d3wBe1F8Ae2ekALqsegBV9qIAK4gjAEG6VQBZbggAISqGADlHgwCJ4+YA5Z7UAEn7QAD/VukAHA/KAMVZigCU+isA08HFAA/FzwDbWq4AR8WGAIVDYgAhhjsALHmUABBhhwAqTHsAgCwaAEO/EgCIJpAAeDyJAKjE5ADl23sAxDrCACb06gD3Z4oADZK/AGWjKwA9k7EAvXwLAKRR3AAn3WMAaeHdAJqUGQCoKZUAaM4oAAnttABEnyAATpjKAHCCYwB+fCMAD7kyAKf1jgAUVucAIfEIALWdKgBvfk0ApRlRALX5qwCC39YAlt1hABY2AgDEOp8Ag6KhAHLtbQA5jXoAgripAGsyXABGJ1sAADTtANIAdwD89FUAAVlNAOBxgABBg+EACz1A+yH5PwAAAAAtRHQ+AAAAgJhG+DwAAABgUcx4OwAAAICDG/A5AAAAQCAlejgAAACAIoLjNgAAAAAd82k1AEHA4QALA+AyUAD3SgRuYW1lAZxKpwEADV9fYXNzZXJ0X2ZhaWwBHF9lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcCH19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24DGF9lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcgQLX19jeGFfdGhyb3cFGF9fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbgYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAccX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZwgbX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nCRZfZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0CiJfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yCxZfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzDCNsZWdhbGltcG9ydCRfZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludA0VZW1zY3JpcHRlbl9tZW1jcHlfYmlnDgVhYm9ydA8VX2VtYmluZF9yZWdpc3Rlcl92b2lkEBZfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsESVfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NsYXNzX2Z1bmN0aW9uEhVfZW1iaW5kX3JlZ2lzdGVyX2Jvb2wTBmRsZnJlZRQbb3BlcmF0b3IgbmV3KHVuc2lnbmVkIGxvbmcpFTxpc19lcXVhbChzdGQ6OnR5cGVfaW5mbyBjb25zdCosIHN0ZDo6dHlwZV9pbmZvIGNvbnN0KiwgYm9vbCkWOnNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXI6OmVuc3VyZUNhcGFjaXR5KHVuc2lnbmVkIGludCkXBm1lbXNldBgOX19keW5hbWljX2Nhc3QZCF9fbWVtY3B5GhhvcGVyYXRvciBkZWxldGVbXSh2b2lkKikbLnN0ZDo6cnVudGltZV9lcnJvcjo6cnVudGltZV9lcnJvcihjaGFyIGNvbnN0KikcB21lbW1vdmUdM3NvdW5kdG91Y2g6OlNvdW5kVG91Y2g6OmNhbGNFZmZlY3RpdmVSYXRlQW5kVGVtcG8oKR4Gc2NhbGJuHwRzYnJrIANjb3MhBV9fc2luIgVfX2NvcyMjc3RkOjpfX3Rocm93X2JhZF9hcnJheV9uZXdfbGVuZ3RoKCkkFVNvdW5kU3RyZXRjaDo6Y2xlYXIoKSUcc3RkOjpleGNlcHRpb246On5leGNlcHRpb24oKSY4c291bmR0b3VjaDo6VERTdHJldGNoOjpzZXRQYXJhbWV0ZXJzKGludCwgaW50LCBpbnQsIGludCknLHNvdW5kdG91Y2g6OlREU3RyZXRjaDo6Y2xlYXJDcm9zc0NvcnJTdGF0ZSgpKD5zb3VuZHRvdWNoOjpQZWFrRmluZGVyOjpnZXRQZWFrQ2VudGVyKGZsb2F0IGNvbnN0KiwgaW50KSBjb25zdCkGbWFsbG9jKgVsZGV4cCsGc3RybGVuLCRzdGQ6OnJ1bnRpbWVfZXJyb3I6On5ydW50aW1lX2Vycm9yKCktInN0ZDo6bG9naWNfZXJyb3I6On5sb2dpY19lcnJvcigpLjEuIHN0ZDo6bG9naWNfZXJyb3I6On5sb2dpY19lcnJvcigpLx5zdGQ6OmxvZ2ljX2Vycm9yOjp3aGF0KCkgY29uc3QwQ3N0ZDo6X18yOjpkZXF1ZTxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+OjpzaHJpbmtfdG9fZml0KCkxiQFzdGQ6Ol9fMjo6X19zcGxpdF9idWZmZXI8ZmxvYXQqLCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Kj4+OjpvcGVyYXRvcj0oc3RkOjpfXzI6Ol9fc3BsaXRfYnVmZmVyPGZsb2F0Kiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdCo+PiYmKTIzc3RkOjpfXzI6Ol9fbGliY3BwX3JlZnN0cmluZzo6fl9fbGliY3BwX3JlZnN0cmluZygpMz1zdGQ6Ol9fMjo6X19saWJjcHBfcmVmc3RyaW5nOjpfX2xpYmNwcF9yZWZzdHJpbmcoY2hhciBjb25zdCopNB9zb3VuZHRvdWNoOjpTb3VuZFRvdWNoOjpmbHVzaCgpNS9zb3VuZHRvdWNoOjpSYXRlVHJhbnNwb3Nlcjo6flJhdGVUcmFuc3Bvc2VyKCkuMTYlc291bmR0b3VjaDo6QlBNRGV0ZWN0Ojp+QlBNRGV0ZWN0KCkuMTdic291bmR0b3VjaDo6QUFGaWx0ZXI6OmV2YWx1YXRlKHNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXImLCBzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyJikgY29uc3Q4J3NvdW5kdG91Y2g6OkFBRmlsdGVyOjpjYWxjdWxhdGVDb2VmZnMoKTkhbGVnYWxmdW5jJF9lbWJpbmRfcmVnaXN0ZXJfYmlnaW50Ov4BZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8dm9pZCAoU291bmRTdHJldGNoOjoqKSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKSwgdm9pZCwgU291bmRTdHJldGNoKiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz46Omludm9rZSh2b2lkIChTb3VuZFN0cmV0Y2g6OiogY29uc3QmKSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKSwgU291bmRTdHJldGNoKiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZyk7pQFlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjx1bnNpZ25lZCBsb25nIChTb3VuZFN0cmV0Y2g6OiopKCksIHVuc2lnbmVkIGxvbmcsIFNvdW5kU3RyZXRjaCo+OjppbnZva2UodW5zaWduZWQgbG9uZyAoU291bmRTdHJldGNoOjoqIGNvbnN0JikoKSwgU291bmRTdHJldGNoKik8qQFlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxTb3VuZFN0cmV0Y2gqLCB1bnNpZ25lZCBsb25nJiYsIHVuc2lnbmVkIGxvbmcmJj46Omludm9rZShTb3VuZFN0cmV0Y2gqICgqKSh1bnNpZ25lZCBsb25nJiYsIHVuc2lnbmVkIGxvbmcmJiksIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcpPRVlbWJpbmRfaW5pdF9idWlsdGluKCk+IGVtYmluZF9pbml0X0NMQVNTX1NvdW5kU3RyZXRjaCgpPx9lbWJpbmRfaW5pdF9DTEFTU19CUE1EZXRlY3RvcigpQApfX3JlbV9waW8yQWZfX2N4eGFiaXYxOjpfX3BvaW50ZXJfdG9fbWVtYmVyX3R5cGVfaW5mbzo6Y2FuX2NhdGNoX25lc3RlZChfX2N4eGFiaXYxOjpfX3NoaW1fdHlwZV9pbmZvIGNvbnN0KikgY29uc3RCgwFfX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6cHJvY2Vzc19zdGF0aWNfdHlwZV9hYm92ZV9kc3QoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQgY29uc3QqLCB2b2lkIGNvbnN0KiwgaW50KSBjb25zdENrX19jeHhhYml2MTo6X19jbGFzc190eXBlX2luZm86OnByb2Nlc3NfZm91bmRfYmFzZV9jbGFzcyhfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCosIGludCkgY29uc3REFlNvdW5kU3RyZXRjaDo6YnVmZmVyKClFRnZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJhd19kZXN0cnVjdG9yPFNvdW5kU3RyZXRjaD4oU291bmRTdHJldGNoKilGRHZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJhd19kZXN0cnVjdG9yPEJQTURldGVjdG9yPihCUE1EZXRlY3RvciopR0x2b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0QWN0dWFsVHlwZTxTb3VuZFN0cmV0Y2g+KFNvdW5kU3RyZXRjaCopSEp2b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0QWN0dWFsVHlwZTxCUE1EZXRlY3Rvcj4oQlBNRGV0ZWN0b3IqKUkmc3RkOjpydW50aW1lX2Vycm9yOjp+cnVudGltZV9lcnJvcigpLjFKHHN0ZDo6ZXhjZXB0aW9uOjp3aGF0KCkgY29uc3RLJ3N0ZDo6YmFkX2FycmF5X25ld19sZW5ndGg6OndoYXQoKSBjb25zdEwcc3RkOjpiYWRfYWxsb2M6OndoYXQoKSBjb25zdE1jc291bmR0b3VjaDo6VHJhbnNwb3NlckJhc2U6OnRyYW5zcG9zZShzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyJiwgc291bmR0b3VjaDo6RklGT1NhbXBsZUJ1ZmZlciYpTitzb3VuZHRvdWNoOjpUcmFuc3Bvc2VyQmFzZTo6c2V0UmF0ZShkb3VibGUpTyxzb3VuZHRvdWNoOjpUcmFuc3Bvc2VyQmFzZTo6c2V0Q2hhbm5lbHMoaW50KVAlc291bmR0b3VjaDo6VERTdHJldGNoOjp+VERTdHJldGNoKCkuMVEjc291bmR0b3VjaDo6VERTdHJldGNoOjp+VERTdHJldGNoKClSPHNvdW5kdG91Y2g6OlREU3RyZXRjaDo6c2Vla0Jlc3RPdmVybGFwUG9zaXRpb24oZmxvYXQgY29uc3QqKVNBc291bmR0b3VjaDo6VERTdHJldGNoOjpzZWVrQmVzdE92ZXJsYXBQb3NpdGlvblF1aWNrKGZsb2F0IGNvbnN0KilUQHNvdW5kdG91Y2g6OlREU3RyZXRjaDo6c2Vla0Jlc3RPdmVybGFwUG9zaXRpb25GdWxsKGZsb2F0IGNvbnN0KilVPXNvdW5kdG91Y2g6OlREU3RyZXRjaDo6cHV0U2FtcGxlcyhmbG9hdCBjb25zdCosIHVuc2lnbmVkIGludClWQHNvdW5kdG91Y2g6OlREU3RyZXRjaDo6b3ZlcmxhcFN0ZXJlbyhmbG9hdCosIGZsb2F0IGNvbnN0KikgY29uc3RXP3NvdW5kdG91Y2g6OlREU3RyZXRjaDo6b3ZlcmxhcE11bHRpKGZsb2F0KiwgZmxvYXQgY29uc3QqKSBjb25zdFg+c291bmR0b3VjaDo6VERTdHJldGNoOjpvdmVybGFwTW9ubyhmbG9hdCosIGZsb2F0IGNvbnN0KikgY29uc3RZHnNvdW5kdG91Y2g6OlREU3RyZXRjaDo6Y2xlYXIoKVpJc291bmR0b3VjaDo6VERTdHJldGNoOjpjYWxjQ3Jvc3NDb3JyKGZsb2F0IGNvbnN0KiwgZmxvYXQgY29uc3QqLCBkb3VibGUmKVtTc291bmR0b3VjaDo6VERTdHJldGNoOjpjYWxjQ3Jvc3NDb3JyQWNjdW11bGF0ZShmbG9hdCBjb25zdCosIGZsb2F0IGNvbnN0KiwgZG91YmxlJilcJ3NvdW5kdG91Y2g6OlNvdW5kVG91Y2g6On5Tb3VuZFRvdWNoKCkuMV0lc291bmR0b3VjaDo6U291bmRUb3VjaDo6flNvdW5kVG91Y2goKV40c291bmR0b3VjaDo6U291bmRUb3VjaDo6cmVjZWl2ZVNhbXBsZXModW5zaWduZWQgaW50KV88c291bmR0b3VjaDo6U291bmRUb3VjaDo6cmVjZWl2ZVNhbXBsZXMoZmxvYXQqLCB1bnNpZ25lZCBpbnQpYD5zb3VuZHRvdWNoOjpTb3VuZFRvdWNoOjpwdXRTYW1wbGVzKGZsb2F0IGNvbnN0KiwgdW5zaWduZWQgaW50KWE1c291bmR0b3VjaDo6U291bmRUb3VjaDo6bnVtVW5wcm9jZXNzZWRTYW1wbGVzKCkgY29uc3RiH3NvdW5kdG91Y2g6OlNvdW5kVG91Y2g6OmNsZWFyKCljLXNvdW5kdG91Y2g6OlJhdGVUcmFuc3Bvc2VyOjp+UmF0ZVRyYW5zcG9zZXIoKWQrc291bmR0b3VjaDo6UmF0ZVRyYW5zcG9zZXI6OnNldFJhdGUoZG91YmxlKWVCc291bmR0b3VjaDo6UmF0ZVRyYW5zcG9zZXI6OnB1dFNhbXBsZXMoZmxvYXQgY29uc3QqLCB1bnNpZ25lZCBpbnQpZitzb3VuZHRvdWNoOjpSYXRlVHJhbnNwb3Nlcjo6aXNFbXB0eSgpIGNvbnN0ZyNzb3VuZHRvdWNoOjpSYXRlVHJhbnNwb3Nlcjo6Y2xlYXIoKWhJc291bmR0b3VjaDo6SW50ZXJwb2xhdGVDdWJpYzo6dHJhbnNwb3NlU3RlcmVvKGZsb2F0KiwgZmxvYXQgY29uc3QqLCBpbnQmKWlIc291bmR0b3VjaDo6SW50ZXJwb2xhdGVDdWJpYzo6dHJhbnNwb3NlTXVsdGkoZmxvYXQqLCBmbG9hdCBjb25zdCosIGludCYpakdzb3VuZHRvdWNoOjpJbnRlcnBvbGF0ZUN1YmljOjp0cmFuc3Bvc2VNb25vKGZsb2F0KiwgZmxvYXQgY29uc3QqLCBpbnQmKWsuc291bmR0b3VjaDo6SW50ZXJwb2xhdGVDdWJpYzo6cmVzZXRSZWdpc3RlcnMoKWwwc291bmR0b3VjaDo6SW50ZXJwb2xhdGVDdWJpYzo6Z2V0TGF0ZW5jeSgpIGNvbnN0bSVzb3VuZHRvdWNoOjpGSVJGaWx0ZXI6On5GSVJGaWx0ZXIoKS4xbiNzb3VuZHRvdWNoOjpGSVJGaWx0ZXI6On5GSVJGaWx0ZXIoKW9Qc291bmR0b3VjaDo6RklSRmlsdGVyOjpzZXRDb2VmZmljaWVudHMoZmxvYXQgY29uc3QqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludClwVXNvdW5kdG91Y2g6OkZJUkZpbHRlcjo6ZXZhbHVhdGVGaWx0ZXJTdGVyZW8oZmxvYXQqLCBmbG9hdCBjb25zdCosIHVuc2lnbmVkIGludCkgY29uc3RxXHNvdW5kdG91Y2g6OkZJUkZpbHRlcjo6ZXZhbHVhdGVGaWx0ZXJNdWx0aShmbG9hdCosIGZsb2F0IGNvbnN0KiwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQpclNzb3VuZHRvdWNoOjpGSVJGaWx0ZXI6OmV2YWx1YXRlRmlsdGVyTW9ubyhmbG9hdCosIGZsb2F0IGNvbnN0KiwgdW5zaWduZWQgaW50KSBjb25zdHMzc291bmR0b3VjaDo6RklGT1NhbXBsZUJ1ZmZlcjo6fkZJRk9TYW1wbGVCdWZmZXIoKS4xdDFzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjp+RklGT1NhbXBsZUJ1ZmZlcigpdTpzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjpyZWNlaXZlU2FtcGxlcyh1bnNpZ25lZCBpbnQpdkJzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjpyZWNlaXZlU2FtcGxlcyhmbG9hdCosIHVuc2lnbmVkIGludCl3NnNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXI6OnB1dFNhbXBsZXModW5zaWduZWQgaW50KXhEc291bmR0b3VjaDo6RklGT1NhbXBsZUJ1ZmZlcjo6cHV0U2FtcGxlcyhmbG9hdCBjb25zdCosIHVuc2lnbmVkIGludCl5KHNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXI6OnB0ckJlZ2luKCl6MHNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXI6Om51bVNhbXBsZXMoKSBjb25zdHstc291bmR0b3VjaDo6RklGT1NhbXBsZUJ1ZmZlcjo6aXNFbXB0eSgpIGNvbnN0fCVzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjpjbGVhcigpfUFzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjphZGp1c3RBbW91bnRPZlNhbXBsZXModW5zaWduZWQgaW50KX43c291bmR0b3VjaDo6RklGT1Byb2Nlc3Nvcjo6cmVjZWl2ZVNhbXBsZXModW5zaWduZWQgaW50KX8/c291bmR0b3VjaDo6RklGT1Byb2Nlc3Nvcjo6cmVjZWl2ZVNhbXBsZXMoZmxvYXQqLCB1bnNpZ25lZCBpbnQpgAElc291bmR0b3VjaDo6RklGT1Byb2Nlc3Nvcjo6cHRyQmVnaW4oKYEBLXNvdW5kdG91Y2g6OkZJRk9Qcm9jZXNzb3I6Om51bVNhbXBsZXMoKSBjb25zdIIBKnNvdW5kdG91Y2g6OkZJRk9Qcm9jZXNzb3I6OmlzRW1wdHkoKSBjb25zdIMBPnNvdW5kdG91Y2g6OkZJRk9Qcm9jZXNzb3I6OmFkanVzdEFtb3VudE9mU2FtcGxlcyh1bnNpZ25lZCBpbnQphAEjc291bmR0b3VjaDo6QlBNRGV0ZWN0Ojp+QlBNRGV0ZWN0KCmFAaYBZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8dm9pZCAoU291bmRTdHJldGNoOjoqKShkb3VibGUpLCB2b2lkLCBTb3VuZFN0cmV0Y2gqLCBkb3VibGU+OjppbnZva2Uodm9pZCAoU291bmRTdHJldGNoOjoqIGNvbnN0JikoZG91YmxlKSwgU291bmRTdHJldGNoKiwgZG91YmxlKYYBigFlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjx2b2lkIChTb3VuZFN0cmV0Y2g6OiopKCksIHZvaWQsIFNvdW5kU3RyZXRjaCo+OjppbnZva2Uodm9pZCAoU291bmRTdHJldGNoOjoqIGNvbnN0JikoKSwgU291bmRTdHJldGNoKimHAZkCZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8dW5zaWduZWQgbG9uZyAoU291bmRTdHJldGNoOjoqKSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKSwgdW5zaWduZWQgbG9uZywgU291bmRTdHJldGNoKiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz46Omludm9rZSh1bnNpZ25lZCBsb25nIChTb3VuZFN0cmV0Y2g6OiogY29uc3QmKSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKSwgU291bmRTdHJldGNoKiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZymIAYsCZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8aW50IChCUE1EZXRlY3Rvcjo6KikodW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgaW50KSwgaW50LCBCUE1EZXRlY3RvciosIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcsIGludD46Omludm9rZShpbnQgKEJQTURldGVjdG9yOjoqIGNvbnN0JikodW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgaW50KSwgQlBNRGV0ZWN0b3IqLCB1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nLCBpbnQpiQGJAWVtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGZsb2F0IChCUE1EZXRlY3Rvcjo6KikoKSwgZmxvYXQsIEJQTURldGVjdG9yKj46Omludm9rZShmbG9hdCAoQlBNRGV0ZWN0b3I6OiogY29uc3QmKSgpLCBCUE1EZXRlY3RvciopigFJZW1zY3JpcHRlbjo6aW50ZXJuYWw6Okludm9rZXI8dW5zaWduZWQgbG9uZz46Omludm9rZSh1bnNpZ25lZCBsb25nICgqKSgpKYsBG19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5nc4wBEV9fd2FzbV9jYWxsX2N0b3JzjQENX19nZXRUeXBlTmFtZY4Bcl9fY3h4YWJpdjE6Ol9fc2lfY2xhc3NfdHlwZV9pbmZvOjpzZWFyY2hfYmVsb3dfZHN0KF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkIGNvbnN0KiwgaW50LCBib29sKSBjb25zdI8Bf19fY3h4YWJpdjE6Ol9fc2lfY2xhc3NfdHlwZV9pbmZvOjpzZWFyY2hfYWJvdmVfZHN0KF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkIGNvbnN0Kiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3SQAXFfX2N4eGFiaXYxOjpfX3NpX2NsYXNzX3R5cGVfaW5mbzo6aGFzX3VuYW1iaWd1b3VzX3B1YmxpY19iYXNlKF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkKiwgaW50KSBjb25zdJEBXV9fY3h4YWJpdjE6Ol9fcG9pbnRlcl90eXBlX2luZm86OmNhbl9jYXRjaChfX2N4eGFiaXYxOjpfX3NoaW1fdHlwZV9pbmZvIGNvbnN0Kiwgdm9pZComKSBjb25zdJIBYV9fY3h4YWJpdjE6Ol9fZnVuZGFtZW50YWxfdHlwZV9pbmZvOjpjYW5fY2F0Y2goX19jeHhhYml2MTo6X19zaGltX3R5cGVfaW5mbyBjb25zdCosIHZvaWQqJikgY29uc3STAW9fX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2JlbG93X2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3SUAXxfX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2Fib3ZlX2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIHZvaWQgY29uc3QqLCBpbnQsIGJvb2wpIGNvbnN0lQFuX19jeHhhYml2MTo6X19jbGFzc190eXBlX2luZm86Omhhc191bmFtYmlndW91c19wdWJsaWNfYmFzZShfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCosIGludCkgY29uc3SWAVtfX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6Y2FuX2NhdGNoKF9fY3h4YWJpdjE6Ol9fc2hpbV90eXBlX2luZm8gY29uc3QqLCB2b2lkKiYpIGNvbnN0lwEVX19jeGFfaXNfcG9pbnRlcl90eXBlmAEeU291bmRTdHJldGNoOjpzZXRUZW1wbyhkb3VibGUpmQEdU291bmRTdHJldGNoOjpzZXRSYXRlKGRvdWJsZSmaAR5Tb3VuZFN0cmV0Y2g6OnNldFBpdGNoKGRvdWJsZSmbASdTb3VuZFN0cmV0Y2g6OnNldFBpdGNoU2VtaVRvbmVzKGRvdWJsZSmcATBTb3VuZFN0cmV0Y2g6OnB1c2godW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZymdATBTb3VuZFN0cmV0Y2g6OnB1bGwodW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZymeARpTb3VuZFN0cmV0Y2g6OmdldFZlcnNpb24oKZ8BH1NvdW5kU3RyZXRjaDo6Z2V0Q2hhbm5lbENvdW50KCmgARVTb3VuZFN0cmV0Y2g6OmZsdXNoKCmhAR9Tb3VuZFN0cmV0Y2g6OmF2YWlsYWJsZSgpIGNvbnN0ogF+U291bmRTdHJldGNoKiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6b3BlcmF0b3JfbmV3PFNvdW5kU3RyZXRjaCwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz4odW5zaWduZWQgbG9uZyYmLCB1bnNpZ25lZCBsb25nJiYpowEtQlBNRGV0ZWN0b3I6OmlucHV0U2FtcGxlcyh1bnNpZ25lZCBsb25nLCBpbnQppAEVQlBNRGV0ZWN0b3I6OmdldEJwbSgppQE4QlBNRGV0ZWN0b3I6OmdldEJlYXRzKHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcsIGludCmmAVRCUE1EZXRlY3RvciogZW1zY3JpcHRlbjo6aW50ZXJuYWw6Om9wZXJhdG9yX25ldzxCUE1EZXRlY3RvciwgaW50LCBpbnQ+KGludCYmLCBpbnQmJikHEgEAD19fc3RhY2tfcG9pbnRlcgk9BgAHLnJvZGF0YQEJLnJvZGF0YS4xAgkucm9kYXRhLjIDCS5yb2RhdGEuMwQJLnJvZGF0YS40BQUuZGF0YQ==";

if (!isDataURI(wasmBinaryFile)) {
 wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary(file) {
 try {
  if (file == wasmBinaryFile && wasmBinary) {
   return new Uint8Array(wasmBinary);
  }
  var binary = tryParseAsDataURI(file);
  if (binary) {
   return binary;
  }
  if (readBinary) {
   return readBinary(file);
  }
  throw "both async and sync fetching of the wasm failed";
 } catch (err) {
  abort(err);
 }
}

function getBinaryPromise() {
 if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
  if (typeof fetch == "function") {
   return fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then(function(response) {
    if (!response["ok"]) {
     throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
    }
    return response["arrayBuffer"]();
   }).catch(function() {
    return getBinary(wasmBinaryFile);
   });
  }
 }
 return Promise.resolve().then(function() {
  return getBinary(wasmBinaryFile);
 });
}

function createWasm() {
 var info = {
  "a": asmLibraryArg
 };
 function receiveInstance(instance, module) {
  var exports = instance.exports;
  Module["asm"] = exports;
  wasmMemory = Module["asm"]["t"];
  updateGlobalBufferAndViews(wasmMemory.buffer);
  wasmTable = Module["asm"]["y"];
  addOnInit(Module["asm"]["u"]);
  removeRunDependency("wasm-instantiate");
 }
 addRunDependency("wasm-instantiate");
 function receiveInstantiationResult(result) {
  receiveInstance(result["instance"]);
 }
 function instantiateArrayBuffer(receiver) {
  return getBinaryPromise().then(function(binary) {
   return WebAssembly.instantiate(binary, info);
  }).then(function(instance) {
   return instance;
  }).then(receiver, function(reason) {
   err("failed to asynchronously prepare wasm: " + reason);
   abort(reason);
  });
 }
 function instantiateAsync() {
  if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && typeof fetch == "function") {
   return fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then(function(response) {
    var result = WebAssembly.instantiateStreaming(response, info);
    return result.then(receiveInstantiationResult, function(reason) {
     err("wasm streaming compile failed: " + reason);
     err("falling back to ArrayBuffer instantiation");
     return instantiateArrayBuffer(receiveInstantiationResult);
    });
   });
  } else {
   return instantiateArrayBuffer(receiveInstantiationResult);
  }
 }
 if (Module["instantiateWasm"]) {
  try {
   var exports = Module["instantiateWasm"](info, receiveInstance);
   return exports;
  } catch (e) {
   err("Module.instantiateWasm callback failed with error: " + e);
   readyPromiseReject(e);
  }
 }
 instantiateAsync().catch(readyPromiseReject);
 return {};
}

function callRuntimeCallbacks(callbacks) {
 while (callbacks.length > 0) {
  callbacks.shift()(Module);
 }
}

function intArrayToString(array) {
 var ret = [];
 for (var i = 0; i < array.length; i++) {
  var chr = array[i];
  if (chr > 255) {
   if (ASSERTIONS) {
    assert(false, "Character code " + chr + " (" + String.fromCharCode(chr) + ")  at offset " + i + " not in 0x00-0xFF.");
   }
   chr &= 255;
  }
  ret.push(String.fromCharCode(chr));
 }
 return ret.join("");
}

function ___assert_fail(condition, filename, line, func) {
 abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [ filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function" ]);
}

function ___cxa_allocate_exception(size) {
 return _malloc(size + 24) + 24;
}

function ExceptionInfo(excPtr) {
 this.excPtr = excPtr;
 this.ptr = excPtr - 24;
 this.set_type = function(type) {
  HEAPU32[this.ptr + 4 >> 2] = type;
 };
 this.get_type = function() {
  return HEAPU32[this.ptr + 4 >> 2];
 };
 this.set_destructor = function(destructor) {
  HEAPU32[this.ptr + 8 >> 2] = destructor;
 };
 this.get_destructor = function() {
  return HEAPU32[this.ptr + 8 >> 2];
 };
 this.set_refcount = function(refcount) {
  HEAP32[this.ptr >> 2] = refcount;
 };
 this.set_caught = function(caught) {
  caught = caught ? 1 : 0;
  HEAP8[this.ptr + 12 >> 0] = caught;
 };
 this.get_caught = function() {
  return HEAP8[this.ptr + 12 >> 0] != 0;
 };
 this.set_rethrown = function(rethrown) {
  rethrown = rethrown ? 1 : 0;
  HEAP8[this.ptr + 13 >> 0] = rethrown;
 };
 this.get_rethrown = function() {
  return HEAP8[this.ptr + 13 >> 0] != 0;
 };
 this.init = function(type, destructor) {
  this.set_adjusted_ptr(0);
  this.set_type(type);
  this.set_destructor(destructor);
  this.set_refcount(0);
  this.set_caught(false);
  this.set_rethrown(false);
 };
 this.add_ref = function() {
  var value = HEAP32[this.ptr >> 2];
  HEAP32[this.ptr >> 2] = value + 1;
 };
 this.release_ref = function() {
  var prev = HEAP32[this.ptr >> 2];
  HEAP32[this.ptr >> 2] = prev - 1;
  return prev === 1;
 };
 this.set_adjusted_ptr = function(adjustedPtr) {
  HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
 };
 this.get_adjusted_ptr = function() {
  return HEAPU32[this.ptr + 16 >> 2];
 };
 this.get_exception_ptr = function() {
  var isPointer = ___cxa_is_pointer_type(this.get_type());
  if (isPointer) {
   return HEAPU32[this.excPtr >> 2];
  }
  var adjusted = this.get_adjusted_ptr();
  if (adjusted !== 0) return adjusted;
  return this.excPtr;
 };
}

var exceptionLast = 0;

var uncaughtExceptionCount = 0;

function ___cxa_throw(ptr, type, destructor) {
 var info = new ExceptionInfo(ptr);
 info.init(type, destructor);
 exceptionLast = ptr;
 uncaughtExceptionCount++;
 throw ptr;
}

function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}

function getShiftFromSize(size) {
 switch (size) {
 case 1:
  return 0;

 case 2:
  return 1;

 case 4:
  return 2;

 case 8:
  return 3;

 default:
  throw new TypeError("Unknown type size: " + size);
 }
}

function embind_init_charCodes() {
 var codes = new Array(256);
 for (var i = 0; i < 256; ++i) {
  codes[i] = String.fromCharCode(i);
 }
 embind_charCodes = codes;
}

var embind_charCodes = undefined;

function readLatin1String(ptr) {
 var ret = "";
 var c = ptr;
 while (HEAPU8[c]) {
  ret += embind_charCodes[HEAPU8[c++]];
 }
 return ret;
}

var awaitingDependencies = {};

var registeredTypes = {};

var typeDependencies = {};

var char_0 = 48;

var char_9 = 57;

function makeLegalFunctionName(name) {
 if (undefined === name) {
  return "_unknown";
 }
 name = name.replace(/[^a-zA-Z0-9_]/g, "$");
 var f = name.charCodeAt(0);
 if (f >= char_0 && f <= char_9) {
  return "_" + name;
 }
 return name;
}

function createNamedFunction(name, body) {
 name = makeLegalFunctionName(name);
 return new Function("body", "return function " + name + "() {\n" + '    "use strict";' + "    return body.apply(this, arguments);\n" + "};\n")(body);
}

function extendError(baseErrorType, errorName) {
 var errorClass = createNamedFunction(errorName, function(message) {
  this.name = errorName;
  this.message = message;
  var stack = new Error(message).stack;
  if (stack !== undefined) {
   this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
  }
 });
 errorClass.prototype = Object.create(baseErrorType.prototype);
 errorClass.prototype.constructor = errorClass;
 errorClass.prototype.toString = function() {
  if (this.message === undefined) {
   return this.name;
  } else {
   return this.name + ": " + this.message;
  }
 };
 return errorClass;
}

var BindingError = undefined;

function throwBindingError(message) {
 throw new BindingError(message);
}

var InternalError = undefined;

function throwInternalError(message) {
 throw new InternalError(message);
}

function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
 myTypes.forEach(function(type) {
  typeDependencies[type] = dependentTypes;
 });
 function onComplete(typeConverters) {
  var myTypeConverters = getTypeConverters(typeConverters);
  if (myTypeConverters.length !== myTypes.length) {
   throwInternalError("Mismatched type converter count");
  }
  for (var i = 0; i < myTypes.length; ++i) {
   registerType(myTypes[i], myTypeConverters[i]);
  }
 }
 var typeConverters = new Array(dependentTypes.length);
 var unregisteredTypes = [];
 var registered = 0;
 dependentTypes.forEach((dt, i) => {
  if (registeredTypes.hasOwnProperty(dt)) {
   typeConverters[i] = registeredTypes[dt];
  } else {
   unregisteredTypes.push(dt);
   if (!awaitingDependencies.hasOwnProperty(dt)) {
    awaitingDependencies[dt] = [];
   }
   awaitingDependencies[dt].push(() => {
    typeConverters[i] = registeredTypes[dt];
    ++registered;
    if (registered === unregisteredTypes.length) {
     onComplete(typeConverters);
    }
   });
  }
 });
 if (0 === unregisteredTypes.length) {
  onComplete(typeConverters);
 }
}

function registerType(rawType, registeredInstance, options = {}) {
 if (!("argPackAdvance" in registeredInstance)) {
  throw new TypeError("registerType registeredInstance requires argPackAdvance");
 }
 var name = registeredInstance.name;
 if (!rawType) {
  throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
 }
 if (registeredTypes.hasOwnProperty(rawType)) {
  if (options.ignoreDuplicateRegistrations) {
   return;
  } else {
   throwBindingError("Cannot register type '" + name + "' twice");
  }
 }
 registeredTypes[rawType] = registeredInstance;
 delete typeDependencies[rawType];
 if (awaitingDependencies.hasOwnProperty(rawType)) {
  var callbacks = awaitingDependencies[rawType];
  delete awaitingDependencies[rawType];
  callbacks.forEach(cb => cb());
 }
}

function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": function(wt) {
   return !!wt;
  },
  "toWireType": function(destructors, o) {
   return o ? trueValue : falseValue;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": function(pointer) {
   var heap;
   if (size === 1) {
    heap = HEAP8;
   } else if (size === 2) {
    heap = HEAP16;
   } else if (size === 4) {
    heap = HEAP32;
   } else {
    throw new TypeError("Unknown boolean type size: " + name);
   }
   return this["fromWireType"](heap[pointer >> shift]);
  },
  destructorFunction: null
 });
}

function ClassHandle_isAliasOf(other) {
 if (!(this instanceof ClassHandle)) {
  return false;
 }
 if (!(other instanceof ClassHandle)) {
  return false;
 }
 var leftClass = this.$$.ptrType.registeredClass;
 var left = this.$$.ptr;
 var rightClass = other.$$.ptrType.registeredClass;
 var right = other.$$.ptr;
 while (leftClass.baseClass) {
  left = leftClass.upcast(left);
  leftClass = leftClass.baseClass;
 }
 while (rightClass.baseClass) {
  right = rightClass.upcast(right);
  rightClass = rightClass.baseClass;
 }
 return leftClass === rightClass && left === right;
}

function shallowCopyInternalPointer(o) {
 return {
  count: o.count,
  deleteScheduled: o.deleteScheduled,
  preservePointerOnDelete: o.preservePointerOnDelete,
  ptr: o.ptr,
  ptrType: o.ptrType,
  smartPtr: o.smartPtr,
  smartPtrType: o.smartPtrType
 };
}

function throwInstanceAlreadyDeleted(obj) {
 function getInstanceTypeName(handle) {
  return handle.$$.ptrType.registeredClass.name;
 }
 throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
}

var finalizationRegistry = false;

function detachFinalizer(handle) {}

function runDestructor($$) {
 if ($$.smartPtr) {
  $$.smartPtrType.rawDestructor($$.smartPtr);
 } else {
  $$.ptrType.registeredClass.rawDestructor($$.ptr);
 }
}

function releaseClassHandle($$) {
 $$.count.value -= 1;
 var toDelete = 0 === $$.count.value;
 if (toDelete) {
  runDestructor($$);
 }
}

function downcastPointer(ptr, ptrClass, desiredClass) {
 if (ptrClass === desiredClass) {
  return ptr;
 }
 if (undefined === desiredClass.baseClass) {
  return null;
 }
 var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
 if (rv === null) {
  return null;
 }
 return desiredClass.downcast(rv);
}

var registeredPointers = {};

function getInheritedInstanceCount() {
 return Object.keys(registeredInstances).length;
}

function getLiveInheritedInstances() {
 var rv = [];
 for (var k in registeredInstances) {
  if (registeredInstances.hasOwnProperty(k)) {
   rv.push(registeredInstances[k]);
  }
 }
 return rv;
}

var deletionQueue = [];

function flushPendingDeletes() {
 while (deletionQueue.length) {
  var obj = deletionQueue.pop();
  obj.$$.deleteScheduled = false;
  obj["delete"]();
 }
}

var delayFunction = undefined;

function setDelayFunction(fn) {
 delayFunction = fn;
 if (deletionQueue.length && delayFunction) {
  delayFunction(flushPendingDeletes);
 }
}

function init_embind() {
 Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
 Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
 Module["flushPendingDeletes"] = flushPendingDeletes;
 Module["setDelayFunction"] = setDelayFunction;
}

var registeredInstances = {};

function getBasestPointer(class_, ptr) {
 if (ptr === undefined) {
  throwBindingError("ptr should not be undefined");
 }
 while (class_.baseClass) {
  ptr = class_.upcast(ptr);
  class_ = class_.baseClass;
 }
 return ptr;
}

function getInheritedInstance(class_, ptr) {
 ptr = getBasestPointer(class_, ptr);
 return registeredInstances[ptr];
}

function makeClassHandle(prototype, record) {
 if (!record.ptrType || !record.ptr) {
  throwInternalError("makeClassHandle requires ptr and ptrType");
 }
 var hasSmartPtrType = !!record.smartPtrType;
 var hasSmartPtr = !!record.smartPtr;
 if (hasSmartPtrType !== hasSmartPtr) {
  throwInternalError("Both smartPtrType and smartPtr must be specified");
 }
 record.count = {
  value: 1
 };
 return attachFinalizer(Object.create(prototype, {
  $$: {
   value: record
  }
 }));
}

function RegisteredPointer_fromWireType(ptr) {
 var rawPointer = this.getPointee(ptr);
 if (!rawPointer) {
  this.destructor(ptr);
  return null;
 }
 var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
 if (undefined !== registeredInstance) {
  if (0 === registeredInstance.$$.count.value) {
   registeredInstance.$$.ptr = rawPointer;
   registeredInstance.$$.smartPtr = ptr;
   return registeredInstance["clone"]();
  } else {
   var rv = registeredInstance["clone"]();
   this.destructor(ptr);
   return rv;
  }
 }
 function makeDefaultHandle() {
  if (this.isSmartPointer) {
   return makeClassHandle(this.registeredClass.instancePrototype, {
    ptrType: this.pointeeType,
    ptr: rawPointer,
    smartPtrType: this,
    smartPtr: ptr
   });
  } else {
   return makeClassHandle(this.registeredClass.instancePrototype, {
    ptrType: this,
    ptr: ptr
   });
  }
 }
 var actualType = this.registeredClass.getActualType(rawPointer);
 var registeredPointerRecord = registeredPointers[actualType];
 if (!registeredPointerRecord) {
  return makeDefaultHandle.call(this);
 }
 var toType;
 if (this.isConst) {
  toType = registeredPointerRecord.constPointerType;
 } else {
  toType = registeredPointerRecord.pointerType;
 }
 var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
 if (dp === null) {
  return makeDefaultHandle.call(this);
 }
 if (this.isSmartPointer) {
  return makeClassHandle(toType.registeredClass.instancePrototype, {
   ptrType: toType,
   ptr: dp,
   smartPtrType: this,
   smartPtr: ptr
  });
 } else {
  return makeClassHandle(toType.registeredClass.instancePrototype, {
   ptrType: toType,
   ptr: dp
  });
 }
}

function attachFinalizer(handle) {
 if ("undefined" === typeof FinalizationRegistry) {
  attachFinalizer = handle => handle;
  return handle;
 }
 finalizationRegistry = new FinalizationRegistry(info => {
  releaseClassHandle(info.$$);
 });
 attachFinalizer = handle => {
  var $$ = handle.$$;
  var hasSmartPtr = !!$$.smartPtr;
  if (hasSmartPtr) {
   var info = {
    $$: $$
   };
   finalizationRegistry.register(handle, info, handle);
  }
  return handle;
 };
 detachFinalizer = handle => finalizationRegistry.unregister(handle);
 return attachFinalizer(handle);
}

function ClassHandle_clone() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.preservePointerOnDelete) {
  this.$$.count.value += 1;
  return this;
 } else {
  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
   $$: {
    value: shallowCopyInternalPointer(this.$$)
   }
  }));
  clone.$$.count.value += 1;
  clone.$$.deleteScheduled = false;
  return clone;
 }
}

function ClassHandle_delete() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
  throwBindingError("Object already scheduled for deletion");
 }
 detachFinalizer(this);
 releaseClassHandle(this.$$);
 if (!this.$$.preservePointerOnDelete) {
  this.$$.smartPtr = undefined;
  this.$$.ptr = undefined;
 }
}

function ClassHandle_isDeleted() {
 return !this.$$.ptr;
}

function ClassHandle_deleteLater() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
  throwBindingError("Object already scheduled for deletion");
 }
 deletionQueue.push(this);
 if (deletionQueue.length === 1 && delayFunction) {
  delayFunction(flushPendingDeletes);
 }
 this.$$.deleteScheduled = true;
 return this;
}

function init_ClassHandle() {
 ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
 ClassHandle.prototype["clone"] = ClassHandle_clone;
 ClassHandle.prototype["delete"] = ClassHandle_delete;
 ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
 ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
}

function ClassHandle() {}

function ensureOverloadTable(proto, methodName, humanName) {
 if (undefined === proto[methodName].overloadTable) {
  var prevFunc = proto[methodName];
  proto[methodName] = function() {
   if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
    throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
   }
   return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
  };
  proto[methodName].overloadTable = [];
  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
 }
}

function exposePublicSymbol(name, value, numArguments) {
 if (Module.hasOwnProperty(name)) {
  if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {
   throwBindingError("Cannot register public name '" + name + "' twice");
  }
  ensureOverloadTable(Module, name, name);
  if (Module.hasOwnProperty(numArguments)) {
   throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
  }
  Module[name].overloadTable[numArguments] = value;
 } else {
  Module[name] = value;
  if (undefined !== numArguments) {
   Module[name].numArguments = numArguments;
  }
 }
}

function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
 this.name = name;
 this.constructor = constructor;
 this.instancePrototype = instancePrototype;
 this.rawDestructor = rawDestructor;
 this.baseClass = baseClass;
 this.getActualType = getActualType;
 this.upcast = upcast;
 this.downcast = downcast;
 this.pureVirtualFunctions = [];
}

function upcastPointer(ptr, ptrClass, desiredClass) {
 while (ptrClass !== desiredClass) {
  if (!ptrClass.upcast) {
   throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
  }
  ptr = ptrClass.upcast(ptr);
  ptrClass = ptrClass.baseClass;
 }
 return ptr;
}

function constNoSmartPtrRawPointerToWireType(destructors, handle) {
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  return 0;
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + embindRepr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 return ptr;
}

function genericPointerToWireType(destructors, handle) {
 var ptr;
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  if (this.isSmartPointer) {
   ptr = this.rawConstructor();
   if (destructors !== null) {
    destructors.push(this.rawDestructor, ptr);
   }
   return ptr;
  } else {
   return 0;
  }
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + embindRepr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 if (!this.isConst && handle.$$.ptrType.isConst) {
  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 if (this.isSmartPointer) {
  if (undefined === handle.$$.smartPtr) {
   throwBindingError("Passing raw pointer to smart pointer is illegal");
  }
  switch (this.sharingPolicy) {
  case 0:
   if (handle.$$.smartPtrType === this) {
    ptr = handle.$$.smartPtr;
   } else {
    throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
   }
   break;

  case 1:
   ptr = handle.$$.smartPtr;
   break;

  case 2:
   if (handle.$$.smartPtrType === this) {
    ptr = handle.$$.smartPtr;
   } else {
    var clonedHandle = handle["clone"]();
    ptr = this.rawShare(ptr, Emval.toHandle(function() {
     clonedHandle["delete"]();
    }));
    if (destructors !== null) {
     destructors.push(this.rawDestructor, ptr);
    }
   }
   break;

  default:
   throwBindingError("Unsupporting sharing policy");
  }
 }
 return ptr;
}

function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  return 0;
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + embindRepr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 if (handle.$$.ptrType.isConst) {
  throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 return ptr;
}

function simpleReadValueFromPointer(pointer) {
 return this["fromWireType"](HEAP32[pointer >> 2]);
}

function RegisteredPointer_getPointee(ptr) {
 if (this.rawGetPointee) {
  ptr = this.rawGetPointee(ptr);
 }
 return ptr;
}

function RegisteredPointer_destructor(ptr) {
 if (this.rawDestructor) {
  this.rawDestructor(ptr);
 }
}

function RegisteredPointer_deleteObject(handle) {
 if (handle !== null) {
  handle["delete"]();
 }
}

function init_RegisteredPointer() {
 RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
 RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
 RegisteredPointer.prototype["argPackAdvance"] = 8;
 RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
 RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
 RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
}

function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
 this.name = name;
 this.registeredClass = registeredClass;
 this.isReference = isReference;
 this.isConst = isConst;
 this.isSmartPointer = isSmartPointer;
 this.pointeeType = pointeeType;
 this.sharingPolicy = sharingPolicy;
 this.rawGetPointee = rawGetPointee;
 this.rawConstructor = rawConstructor;
 this.rawShare = rawShare;
 this.rawDestructor = rawDestructor;
 if (!isSmartPointer && registeredClass.baseClass === undefined) {
  if (isConst) {
   this["toWireType"] = constNoSmartPtrRawPointerToWireType;
   this.destructorFunction = null;
  } else {
   this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
   this.destructorFunction = null;
  }
 } else {
  this["toWireType"] = genericPointerToWireType;
 }
}

function replacePublicSymbol(name, value, numArguments) {
 if (!Module.hasOwnProperty(name)) {
  throwInternalError("Replacing nonexistant public symbol");
 }
 if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
  Module[name].overloadTable[numArguments] = value;
 } else {
  Module[name] = value;
  Module[name].argCount = numArguments;
 }
}

function dynCallLegacy(sig, ptr, args) {
 var f = Module["dynCall_" + sig];
 return args && args.length ? f.apply(null, [ ptr ].concat(args)) : f.call(null, ptr);
}

var wasmTableMirror = [];

function getWasmTableEntry(funcPtr) {
 var func = wasmTableMirror[funcPtr];
 if (!func) {
  if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
  wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
 }
 return func;
}

function dynCall(sig, ptr, args) {
 if (sig.includes("j")) {
  return dynCallLegacy(sig, ptr, args);
 }
 var rtn = getWasmTableEntry(ptr).apply(null, args);
 return rtn;
}

function getDynCaller(sig, ptr) {
 var argCache = [];
 return function() {
  argCache.length = 0;
  Object.assign(argCache, arguments);
  return dynCall(sig, ptr, argCache);
 };
}

function embind__requireFunction(signature, rawFunction) {
 signature = readLatin1String(signature);
 function makeDynCaller() {
  if (signature.includes("j")) {
   return getDynCaller(signature, rawFunction);
  }
  return getWasmTableEntry(rawFunction);
 }
 var fp = makeDynCaller();
 if (typeof fp != "function") {
  throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
 }
 return fp;
}

var UnboundTypeError = undefined;

function getTypeName(type) {
 var ptr = ___getTypeName(type);
 var rv = readLatin1String(ptr);
 _free(ptr);
 return rv;
}

function throwUnboundTypeError(message, types) {
 var unboundTypes = [];
 var seen = {};
 function visit(type) {
  if (seen[type]) {
   return;
  }
  if (registeredTypes[type]) {
   return;
  }
  if (typeDependencies[type]) {
   typeDependencies[type].forEach(visit);
   return;
  }
  unboundTypes.push(type);
  seen[type] = true;
 }
 types.forEach(visit);
 throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([ ", " ]));
}

function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
 name = readLatin1String(name);
 getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
 if (upcast) {
  upcast = embind__requireFunction(upcastSignature, upcast);
 }
 if (downcast) {
  downcast = embind__requireFunction(downcastSignature, downcast);
 }
 rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
 var legalFunctionName = makeLegalFunctionName(name);
 exposePublicSymbol(legalFunctionName, function() {
  throwUnboundTypeError("Cannot construct " + name + " due to unbound types", [ baseClassRawType ]);
 });
 whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], function(base) {
  base = base[0];
  var baseClass;
  var basePrototype;
  if (baseClassRawType) {
   baseClass = base.registeredClass;
   basePrototype = baseClass.instancePrototype;
  } else {
   basePrototype = ClassHandle.prototype;
  }
  var constructor = createNamedFunction(legalFunctionName, function() {
   if (Object.getPrototypeOf(this) !== instancePrototype) {
    throw new BindingError("Use 'new' to construct " + name);
   }
   if (undefined === registeredClass.constructor_body) {
    throw new BindingError(name + " has no accessible constructor");
   }
   var body = registeredClass.constructor_body[arguments.length];
   if (undefined === body) {
    throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
   }
   return body.apply(this, arguments);
  });
  var instancePrototype = Object.create(basePrototype, {
   constructor: {
    value: constructor
   }
  });
  constructor.prototype = instancePrototype;
  var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
  var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
  var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
  var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
  registeredPointers[rawType] = {
   pointerType: pointerConverter,
   constPointerType: constPointerConverter
  };
  replacePublicSymbol(legalFunctionName, constructor);
  return [ referenceConverter, pointerConverter, constPointerConverter ];
 });
}

function new_(constructor, argumentList) {
 if (!(constructor instanceof Function)) {
  throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
 }
 var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {});
 dummy.prototype = constructor.prototype;
 var obj = new dummy();
 var r = constructor.apply(obj, argumentList);
 return r instanceof Object ? r : obj;
}

function runDestructors(destructors) {
 while (destructors.length) {
  var ptr = destructors.pop();
  var del = destructors.pop();
  del(ptr);
 }
}

function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
 var argCount = argTypes.length;
 if (argCount < 2) {
  throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
 }
 var isClassMethodFunc = argTypes[1] !== null && classType !== null;
 var needsDestructorStack = false;
 for (var i = 1; i < argTypes.length; ++i) {
  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
   needsDestructorStack = true;
   break;
  }
 }
 var returns = argTypes[0].name !== "void";
 var argsList = "";
 var argsListWired = "";
 for (var i = 0; i < argCount - 2; ++i) {
  argsList += (i !== 0 ? ", " : "") + "arg" + i;
  argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
 }
 var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\n" + "if (arguments.length !== " + (argCount - 2) + ") {\n" + "throwBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n" + "}\n";
 if (needsDestructorStack) {
  invokerFnBody += "var destructors = [];\n";
 }
 var dtorStack = needsDestructorStack ? "destructors" : "null";
 var args1 = [ "throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam" ];
 var args2 = [ throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];
 if (isClassMethodFunc) {
  invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
 }
 for (var i = 0; i < argCount - 2; ++i) {
  invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
  args1.push("argType" + i);
  args2.push(argTypes[i + 2]);
 }
 if (isClassMethodFunc) {
  argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
 }
 invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
 if (needsDestructorStack) {
  invokerFnBody += "runDestructors(destructors);\n";
 } else {
  for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
   var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
   if (argTypes[i].destructorFunction !== null) {
    invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
    args1.push(paramName + "_dtor");
    args2.push(argTypes[i].destructorFunction);
   }
  }
 }
 if (returns) {
  invokerFnBody += "var ret = retType.fromWireType(rv);\n" + "return ret;\n";
 } else {}
 invokerFnBody += "}\n";
 args1.push(invokerFnBody);
 var invokerFunction = new_(Function, args1).apply(null, args2);
 return invokerFunction;
}

function heap32VectorToArray(count, firstElement) {
 var array = [];
 for (var i = 0; i < count; i++) {
  array.push(HEAPU32[firstElement + i * 4 >> 2]);
 }
 return array;
}

function __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn) {
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 methodName = readLatin1String(methodName);
 rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + methodName;
  function unboundTypesHandler() {
   throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
  }
  if (methodName.startsWith("@@")) {
   methodName = Symbol[methodName.substring(2)];
  }
  var proto = classType.registeredClass.constructor;
  if (undefined === proto[methodName]) {
   unboundTypesHandler.argCount = argCount - 1;
   proto[methodName] = unboundTypesHandler;
  } else {
   ensureOverloadTable(proto, methodName, humanName);
   proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;
  }
  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
   var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));
   var func = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn);
   if (undefined === proto[methodName].overloadTable) {
    func.argCount = argCount - 1;
    proto[methodName] = func;
   } else {
    proto[methodName].overloadTable[argCount - 1] = func;
   }
   return [];
  });
  return [];
 });
}

function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
 assert(argCount > 0);
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 invoker = embind__requireFunction(invokerSignature, invoker);
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = "constructor " + classType.name;
  if (undefined === classType.registeredClass.constructor_body) {
   classType.registeredClass.constructor_body = [];
  }
  if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
   throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
  }
  classType.registeredClass.constructor_body[argCount - 1] = () => {
   throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
  };
  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
   argTypes.splice(1, 0, null);
   classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
   return [];
  });
  return [];
 });
}

function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 methodName = readLatin1String(methodName);
 rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + methodName;
  if (methodName.startsWith("@@")) {
   methodName = Symbol[methodName.substring(2)];
  }
  if (isPureVirtual) {
   classType.registeredClass.pureVirtualFunctions.push(methodName);
  }
  function unboundTypesHandler() {
   throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
  }
  var proto = classType.registeredClass.instancePrototype;
  var method = proto[methodName];
  if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
   unboundTypesHandler.argCount = argCount - 2;
   unboundTypesHandler.className = classType.name;
   proto[methodName] = unboundTypesHandler;
  } else {
   ensureOverloadTable(proto, methodName, humanName);
   proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
  }
  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
   var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
   if (undefined === proto[methodName].overloadTable) {
    memberFunction.argCount = argCount - 2;
    proto[methodName] = memberFunction;
   } else {
    proto[methodName].overloadTable[argCount - 2] = memberFunction;
   }
   return [];
  });
  return [];
 });
}

var emval_free_list = [];

var emval_handle_array = [ {}, {
 value: undefined
}, {
 value: null
}, {
 value: true
}, {
 value: false
} ];

function __emval_decref(handle) {
 if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
  emval_handle_array[handle] = undefined;
  emval_free_list.push(handle);
 }
}

function count_emval_handles() {
 var count = 0;
 for (var i = 5; i < emval_handle_array.length; ++i) {
  if (emval_handle_array[i] !== undefined) {
   ++count;
  }
 }
 return count;
}

function get_first_emval() {
 for (var i = 5; i < emval_handle_array.length; ++i) {
  if (emval_handle_array[i] !== undefined) {
   return emval_handle_array[i];
  }
 }
 return null;
}

function init_emval() {
 Module["count_emval_handles"] = count_emval_handles;
 Module["get_first_emval"] = get_first_emval;
}

var Emval = {
 toValue: handle => {
  if (!handle) {
   throwBindingError("Cannot use deleted val. handle = " + handle);
  }
  return emval_handle_array[handle].value;
 },
 toHandle: value => {
  switch (value) {
  case undefined:
   return 1;

  case null:
   return 2;

  case true:
   return 3;

  case false:
   return 4;

  default:
   {
    var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
    emval_handle_array[handle] = {
     refcount: 1,
     value: value
    };
    return handle;
   }
  }
 }
};

function __embind_register_emval(rawType, name) {
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": function(handle) {
   var rv = Emval.toValue(handle);
   __emval_decref(handle);
   return rv;
  },
  "toWireType": function(destructors, value) {
   return Emval.toHandle(value);
  },
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: null
 });
}

function embindRepr(v) {
 if (v === null) {
  return "null";
 }
 var t = typeof v;
 if (t === "object" || t === "array" || t === "function") {
  return v.toString();
 } else {
  return "" + v;
 }
}

function floatReadValueFromPointer(name, shift) {
 switch (shift) {
 case 2:
  return function(pointer) {
   return this["fromWireType"](HEAPF32[pointer >> 2]);
  };

 case 3:
  return function(pointer) {
   return this["fromWireType"](HEAPF64[pointer >> 3]);
  };

 default:
  throw new TypeError("Unknown float type: " + name);
 }
}

function __embind_register_float(rawType, name, size) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": function(value) {
   return value;
  },
  "toWireType": function(destructors, value) {
   return value;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": floatReadValueFromPointer(name, shift),
  destructorFunction: null
 });
}

function integerReadValueFromPointer(name, shift, signed) {
 switch (shift) {
 case 0:
  return signed ? function readS8FromPointer(pointer) {
   return HEAP8[pointer];
  } : function readU8FromPointer(pointer) {
   return HEAPU8[pointer];
  };

 case 1:
  return signed ? function readS16FromPointer(pointer) {
   return HEAP16[pointer >> 1];
  } : function readU16FromPointer(pointer) {
   return HEAPU16[pointer >> 1];
  };

 case 2:
  return signed ? function readS32FromPointer(pointer) {
   return HEAP32[pointer >> 2];
  } : function readU32FromPointer(pointer) {
   return HEAPU32[pointer >> 2];
  };

 default:
  throw new TypeError("Unknown integer type: " + name);
 }
}

function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
 name = readLatin1String(name);
 if (maxRange === -1) {
  maxRange = 4294967295;
 }
 var shift = getShiftFromSize(size);
 var fromWireType = value => value;
 if (minRange === 0) {
  var bitshift = 32 - 8 * size;
  fromWireType = value => value << bitshift >>> bitshift;
 }
 var isUnsignedType = name.includes("unsigned");
 var checkAssertions = (value, toTypeName) => {};
 var toWireType;
 if (isUnsignedType) {
  toWireType = function(destructors, value) {
   checkAssertions(value, this.name);
   return value >>> 0;
  };
 } else {
  toWireType = function(destructors, value) {
   checkAssertions(value, this.name);
   return value;
  };
 }
 registerType(primitiveType, {
  name: name,
  "fromWireType": fromWireType,
  "toWireType": toWireType,
  "argPackAdvance": 8,
  "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0),
  destructorFunction: null
 });
}

function __embind_register_memory_view(rawType, dataTypeIndex, name) {
 var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];
 var TA = typeMapping[dataTypeIndex];
 function decodeMemoryView(handle) {
  handle = handle >> 2;
  var heap = HEAPU32;
  var size = heap[handle];
  var data = heap[handle + 1];
  return new TA(buffer, data, size);
 }
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": decodeMemoryView,
  "argPackAdvance": 8,
  "readValueFromPointer": decodeMemoryView
 }, {
  ignoreDuplicateRegistrations: true
 });
}

function __embind_register_std_string(rawType, name) {
 name = readLatin1String(name);
 var stdStringIsUTF8 = name === "std::string";
 registerType(rawType, {
  name: name,
  "fromWireType": function(value) {
   var length = HEAPU32[value >> 2];
   var payload = value + 4;
   var str;
   if (stdStringIsUTF8) {
    var decodeStartPtr = payload;
    for (var i = 0; i <= length; ++i) {
     var currentBytePtr = payload + i;
     if (i == length || HEAPU8[currentBytePtr] == 0) {
      var maxRead = currentBytePtr - decodeStartPtr;
      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
      if (str === undefined) {
       str = stringSegment;
      } else {
       str += String.fromCharCode(0);
       str += stringSegment;
      }
      decodeStartPtr = currentBytePtr + 1;
     }
    }
   } else {
    var a = new Array(length);
    for (var i = 0; i < length; ++i) {
     a[i] = String.fromCharCode(HEAPU8[payload + i]);
    }
    str = a.join("");
   }
   _free(value);
   return str;
  },
  "toWireType": function(destructors, value) {
   if (value instanceof ArrayBuffer) {
    value = new Uint8Array(value);
   }
   var length;
   var valueIsOfTypeString = typeof value == "string";
   if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
    throwBindingError("Cannot pass non-string to std::string");
   }
   if (stdStringIsUTF8 && valueIsOfTypeString) {
    length = lengthBytesUTF8(value);
   } else {
    length = value.length;
   }
   var base = _malloc(4 + length + 1);
   var ptr = base + 4;
   HEAPU32[base >> 2] = length;
   if (stdStringIsUTF8 && valueIsOfTypeString) {
    stringToUTF8(value, ptr, length + 1);
   } else {
    if (valueIsOfTypeString) {
     for (var i = 0; i < length; ++i) {
      var charCode = value.charCodeAt(i);
      if (charCode > 255) {
       _free(ptr);
       throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
      }
      HEAPU8[ptr + i] = charCode;
     }
    } else {
     for (var i = 0; i < length; ++i) {
      HEAPU8[ptr + i] = value[i];
     }
    }
   }
   if (destructors !== null) {
    destructors.push(_free, base);
   }
   return base;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: function(ptr) {
   _free(ptr);
  }
 });
}

var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
 var endPtr = ptr;
 var idx = endPtr >> 1;
 var maxIdx = idx + maxBytesToRead / 2;
 while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
 endPtr = idx << 1;
 if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
 var str = "";
 for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
  var codeUnit = HEAP16[ptr + i * 2 >> 1];
  if (codeUnit == 0) break;
  str += String.fromCharCode(codeUnit);
 }
 return str;
}

function stringToUTF16(str, outPtr, maxBytesToWrite) {
 if (maxBytesToWrite === undefined) {
  maxBytesToWrite = 2147483647;
 }
 if (maxBytesToWrite < 2) return 0;
 maxBytesToWrite -= 2;
 var startPtr = outPtr;
 var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
 for (var i = 0; i < numCharsToWrite; ++i) {
  var codeUnit = str.charCodeAt(i);
  HEAP16[outPtr >> 1] = codeUnit;
  outPtr += 2;
 }
 HEAP16[outPtr >> 1] = 0;
 return outPtr - startPtr;
}

function lengthBytesUTF16(str) {
 return str.length * 2;
}

function UTF32ToString(ptr, maxBytesToRead) {
 var i = 0;
 var str = "";
 while (!(i >= maxBytesToRead / 4)) {
  var utf32 = HEAP32[ptr + i * 4 >> 2];
  if (utf32 == 0) break;
  ++i;
  if (utf32 >= 65536) {
   var ch = utf32 - 65536;
   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
  } else {
   str += String.fromCharCode(utf32);
  }
 }
 return str;
}

function stringToUTF32(str, outPtr, maxBytesToWrite) {
 if (maxBytesToWrite === undefined) {
  maxBytesToWrite = 2147483647;
 }
 if (maxBytesToWrite < 4) return 0;
 var startPtr = outPtr;
 var endPtr = startPtr + maxBytesToWrite - 4;
 for (var i = 0; i < str.length; ++i) {
  var codeUnit = str.charCodeAt(i);
  if (codeUnit >= 55296 && codeUnit <= 57343) {
   var trailSurrogate = str.charCodeAt(++i);
   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
  }
  HEAP32[outPtr >> 2] = codeUnit;
  outPtr += 4;
  if (outPtr + 4 > endPtr) break;
 }
 HEAP32[outPtr >> 2] = 0;
 return outPtr - startPtr;
}

function lengthBytesUTF32(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var codeUnit = str.charCodeAt(i);
  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;
  len += 4;
 }
 return len;
}

function __embind_register_std_wstring(rawType, charSize, name) {
 name = readLatin1String(name);
 var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
 if (charSize === 2) {
  decodeString = UTF16ToString;
  encodeString = stringToUTF16;
  lengthBytesUTF = lengthBytesUTF16;
  getHeap = () => HEAPU16;
  shift = 1;
 } else if (charSize === 4) {
  decodeString = UTF32ToString;
  encodeString = stringToUTF32;
  lengthBytesUTF = lengthBytesUTF32;
  getHeap = () => HEAPU32;
  shift = 2;
 }
 registerType(rawType, {
  name: name,
  "fromWireType": function(value) {
   var length = HEAPU32[value >> 2];
   var HEAP = getHeap();
   var str;
   var decodeStartPtr = value + 4;
   for (var i = 0; i <= length; ++i) {
    var currentBytePtr = value + 4 + i * charSize;
    if (i == length || HEAP[currentBytePtr >> shift] == 0) {
     var maxReadBytes = currentBytePtr - decodeStartPtr;
     var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
     if (str === undefined) {
      str = stringSegment;
     } else {
      str += String.fromCharCode(0);
      str += stringSegment;
     }
     decodeStartPtr = currentBytePtr + charSize;
    }
   }
   _free(value);
   return str;
  },
  "toWireType": function(destructors, value) {
   if (!(typeof value == "string")) {
    throwBindingError("Cannot pass non-string to C++ string type " + name);
   }
   var length = lengthBytesUTF(value);
   var ptr = _malloc(4 + length + charSize);
   HEAPU32[ptr >> 2] = length >> shift;
   encodeString(value, ptr + 4, length + charSize);
   if (destructors !== null) {
    destructors.push(_free, ptr);
   }
   return ptr;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: function(ptr) {
   _free(ptr);
  }
 });
}

function __embind_register_void(rawType, name) {
 name = readLatin1String(name);
 registerType(rawType, {
  isVoid: true,
  name: name,
  "argPackAdvance": 0,
  "fromWireType": function() {
   return undefined;
  },
  "toWireType": function(destructors, o) {
   return undefined;
  }
 });
}

function _abort() {
 abort("");
}

function _emscripten_memcpy_big(dest, src, num) {
 HEAPU8.copyWithin(dest, src, src + num);
}

function getHeapMax() {
 return 2147483648;
}

function emscripten_realloc_buffer(size) {
 try {
  wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
  updateGlobalBufferAndViews(wasmMemory.buffer);
  return 1;
 } catch (e) {}
}

function _emscripten_resize_heap(requestedSize) {
 var oldSize = HEAPU8.length;
 requestedSize = requestedSize >>> 0;
 var maxHeapSize = getHeapMax();
 if (requestedSize > maxHeapSize) {
  return false;
 }
 let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
 for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
  var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
  overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
  var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
  var replacement = emscripten_realloc_buffer(newSize);
  if (replacement) {
   return true;
  }
 }
 return false;
}

embind_init_charCodes();

BindingError = Module["BindingError"] = extendError(Error, "BindingError");

InternalError = Module["InternalError"] = extendError(Error, "InternalError");

init_ClassHandle();

init_embind();

init_RegisteredPointer();

UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");

init_emval();

var ASSERTIONS = false;

var decodeBase64 = typeof atob == "function" ? atob : function(input) {
 var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
 var output = "";
 var chr1, chr2, chr3;
 var enc1, enc2, enc3, enc4;
 var i = 0;
 input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
 do {
  enc1 = keyStr.indexOf(input.charAt(i++));
  enc2 = keyStr.indexOf(input.charAt(i++));
  enc3 = keyStr.indexOf(input.charAt(i++));
  enc4 = keyStr.indexOf(input.charAt(i++));
  chr1 = enc1 << 2 | enc2 >> 4;
  chr2 = (enc2 & 15) << 4 | enc3 >> 2;
  chr3 = (enc3 & 3) << 6 | enc4;
  output = output + String.fromCharCode(chr1);
  if (enc3 !== 64) {
   output = output + String.fromCharCode(chr2);
  }
  if (enc4 !== 64) {
   output = output + String.fromCharCode(chr3);
  }
 } while (i < input.length);
 return output;
};

function intArrayFromBase64(s) {
 try {
  var decoded = decodeBase64(s);
  var bytes = new Uint8Array(decoded.length);
  for (var i = 0; i < decoded.length; ++i) {
   bytes[i] = decoded.charCodeAt(i);
  }
  return bytes;
 } catch (_) {
  throw new Error("Converting base64 string to bytes failed.");
 }
}

function tryParseAsDataURI(filename) {
 if (!isDataURI(filename)) {
  return;
 }
 return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}

var asmLibraryArg = {
 "a": ___assert_fail,
 "f": ___cxa_allocate_exception,
 "e": ___cxa_throw,
 "m": __embind_register_bigint,
 "s": __embind_register_bool,
 "l": __embind_register_class,
 "r": __embind_register_class_class_function,
 "k": __embind_register_class_constructor,
 "c": __embind_register_class_function,
 "q": __embind_register_emval,
 "j": __embind_register_float,
 "d": __embind_register_integer,
 "b": __embind_register_memory_view,
 "i": __embind_register_std_string,
 "h": __embind_register_std_wstring,
 "p": __embind_register_void,
 "o": _abort,
 "n": _emscripten_memcpy_big,
 "g": _emscripten_resize_heap
};

var asm = createWasm();

var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
 return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["u"]).apply(null, arguments);
};

var ___getTypeName = Module["___getTypeName"] = function() {
 return (___getTypeName = Module["___getTypeName"] = Module["asm"]["v"]).apply(null, arguments);
};

var __embind_initialize_bindings = Module["__embind_initialize_bindings"] = function() {
 return (__embind_initialize_bindings = Module["__embind_initialize_bindings"] = Module["asm"]["w"]).apply(null, arguments);
};

var _malloc = Module["_malloc"] = function() {
 return (_malloc = Module["_malloc"] = Module["asm"]["x"]).apply(null, arguments);
};

var _free = Module["_free"] = function() {
 return (_free = Module["_free"] = Module["asm"]["z"]).apply(null, arguments);
};

var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = function() {
 return (___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = Module["asm"]["A"]).apply(null, arguments);
};

var calledRun;

dependenciesFulfilled = function runCaller() {
 if (!calledRun) run();
 if (!calledRun) dependenciesFulfilled = runCaller;
};

function run(args) {
 args = args || arguments_;
 if (runDependencies > 0) {
  return;
 }
 preRun();
 if (runDependencies > 0) {
  return;
 }
 function doRun() {
  if (calledRun) return;
  calledRun = true;
  Module["calledRun"] = true;
  if (ABORT) return;
  initRuntime();
  readyPromiseResolve(Module);
  if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
  postRun();
 }
 if (Module["setStatus"]) {
  Module["setStatus"]("Running...");
  setTimeout(function() {
   setTimeout(function() {
    Module["setStatus"]("");
   }, 1);
   doRun();
  }, 1);
 } else {
  doRun();
 }
}

if (Module["preInit"]) {
 if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
 while (Module["preInit"].length > 0) {
  Module["preInit"].pop()();
 }
}

run();


  return Module.ready
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = Module;
else if (typeof define === 'function' && define['amd'])
  define([], function() { return Module; });
else if (typeof exports === 'object')
  exports["Module"] = Module;
