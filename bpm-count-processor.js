/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/web/Float32ChannelTransport.ts":
/*!********************************************!*\
  !*** ./src/web/Float32ChannelTransport.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Float32ChannelTransport\": () => (/* binding */ Float32ChannelTransport)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar Float32ChannelTransport = /*#__PURE__*/function () {\n  function Float32ChannelTransport(module, sampleSize) {\n    var channelCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    _classCallCheck(this, Float32ChannelTransport);\n    _defineProperty(this, \"_module\", void 0);\n    _defineProperty(this, \"_ptr\", void 0);\n    _defineProperty(this, \"_channelCount\", void 0);\n    _defineProperty(this, \"_sampleSize\", void 0);\n    _defineProperty(this, \"_closed\", false);\n    this._module = module;\n    if (sampleSize < 1) throw new Error('Invalid sampleSize');\n    this._sampleSize = sampleSize;\n    if (channelCount < 1) throw new Error('Invalid channelCount');\n    this._channelCount = channelCount;\n    this._ptr = this._module._malloc(this._channelCount * this._sampleSize * Float32Array.BYTES_PER_ELEMENT);\n  }\n  _createClass(Float32ChannelTransport, [{\n    key: \"getPointer\",\n    value: function getPointer(channel) {\n      if (this._closed) throw new Error('Already closed');\n      if (channel) {\n        if (channel < 0 || channel > this._channelCount) throw new Error('Channel out of bounce');\n        return this._ptr + channel * this._sampleSize;\n      }\n      return this._ptr;\n    }\n  }, {\n    key: \"current\",\n    get: function get() {\n      if (this._closed) {\n        throw new Error('Already closed');\n      }\n      return new Float32Array(this._module.HEAPF32.buffer, this._ptr, this._channelCount * this._sampleSize);\n    }\n  }, {\n    key: \"write\",\n    value: function write(input) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var len = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (offset > this._sampleSize) throw new Error('Invalid offset');\n      var channelCount = Math.min(input.length, this._channelCount);\n      for (var c = 0; c < channelCount; ++c) {\n        var length = len || Math.min(input[c].length, this._sampleSize - offset);\n        var output = this.current;\n        var channel = input[c].subarray(0, length);\n        output.set(channel, c * len + offset);\n      }\n    }\n  }, {\n    key: \"read\",\n    value: function read(output) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var len = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (offset > this._sampleSize) throw new Error('Invalid offset');\n      if (!output) {\n        output = [];\n        for (var c = 0; c < this._channelCount; ++c) {\n          output.push(new Float32Array(this._sampleSize));\n        }\n      }\n      if (output.length > 0) {\n        var input = this.current;\n        var channelCount = Math.min(output.length, this._channelCount);\n        for (var _c = 0; _c < channelCount; ++_c) {\n          var start = _c * this._sampleSize;\n          var length = len || Math.min(output[_c].length - offset, this._sampleSize);\n          var end = start + length;\n          var channel = input.subarray(start, end);\n          output[_c].set(channel, offset);\n        }\n      }\n      return output;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this._closed = true;\n      this._module._free(this._ptr);\n    }\n  }]);\n  return Float32ChannelTransport;\n}();\n\n\n//# sourceURL=webpack://soundstretch-web/./src/web/Float32ChannelTransport.ts?");

/***/ }),

/***/ "./src/worklet/bpm-count-processor.ts":
/*!********************************************!*\
  !*** ./src/worklet/bpm-count-processor.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _web_Float32ChannelTransport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../web/Float32ChannelTransport */ \"./src/web/Float32ChannelTransport.ts\");\n/* harmony import */ var _wasm_build_soundtouch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../wasm/build/soundtouch.js */ \"./wasm/build/soundtouch.js\");\n/* harmony import */ var _wasm_build_soundtouch_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wasm_build_soundtouch_js__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar RENDER_QUANTUM_FRAMES = 128;\nvar BpmCountProcessor = /*#__PURE__*/function (_AudioWorkletProcesso) {\n  _inherits(BpmCountProcessor, _AudioWorkletProcesso);\n  var _super = _createSuper(BpmCountProcessor);\n  function BpmCountProcessor() {\n    var _this;\n    _classCallCheck(this, BpmCountProcessor);\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"module\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"api\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"inputBuffer\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"channelCount\", 1);\n    _this.port.onmessageerror = function (err) {\n      console.error('onmessageerror', err);\n    };\n    _this.port.onmessage = function (_ref) {\n      var data = _ref.data;\n      if (_typeof(data) === 'object' && data['event']) {\n        var event = data.event;\n        switch (event) {\n          case 'bpm':\n            {\n              var _this$api;\n              console.log(\"[bpm-count-processor] bpm requested\");\n              _this.port.postMessage({\n                event: 'bpm',\n                bpm: ((_this$api = _this.api) === null || _this$api === void 0 ? void 0 : _this$api.getBpm()) || 0\n              });\n              break;\n            }\n          case 'beats':\n            {\n              console.log(\"[bpm-count-processor] beats requested\");\n              if (data.limit === undefined) throw new Error('Missing limit key');\n              var limit = parseInt(data.limit);\n              if (limit === Number.NaN) throw new Error(\"Invalid limit key \".concat(data.limit));\n              if (_this.api && _this.module) {\n                var beats = [];\n                var positionBuffer = new _web_Float32ChannelTransport__WEBPACK_IMPORTED_MODULE_0__.Float32ChannelTransport(_this.module, limit, 1);\n                var strengthBuffer = new _web_Float32ChannelTransport__WEBPACK_IMPORTED_MODULE_0__.Float32ChannelTransport(_this.module, limit, 1);\n                var actual = _this.api.getBeats(positionBuffer.getPointer(), strengthBuffer.getPointer(), limit);\n                var positionArray = positionBuffer.read();\n                var strengthArray = strengthBuffer.read();\n                positionBuffer.close();\n                strengthBuffer.close();\n                for (var i = 0; i < actual; ++i) {\n                  beats.push({\n                    position: positionArray[0][i],\n                    strength: strengthArray[0][i]\n                  });\n                }\n                _this.port.postMessage({\n                  event: 'beats',\n                  beats: beats\n                });\n              } else {\n                _this.port.postMessage({\n                  event: 'beats',\n                  beats: []\n                });\n              }\n              break;\n            }\n        }\n      }\n    };\n    _wasm_build_soundtouch_js__WEBPACK_IMPORTED_MODULE_1__().then(function (module) {\n      _this.module = module;\n      _this.init(1);\n    });\n    return _this;\n  }\n  _createClass(BpmCountProcessor, [{\n    key: \"init\",\n    value: function init(channelCount) {\n      this.channelCount = channelCount;\n      if (this.module) {\n        this.api = new this.module.BPMDetector(channelCount, sampleRate);\n        this.inputBuffer = new _web_Float32ChannelTransport__WEBPACK_IMPORTED_MODULE_0__.Float32ChannelTransport(this.module, RENDER_QUANTUM_FRAMES, channelCount);\n      }\n    }\n  }, {\n    key: \"process\",\n    value: function process(inputs, outputs) {\n      if (inputs.length > 0 && inputs[0].length > 0) {\n        var channelCount = inputs[0].length;\n        if (!this.api || this.channelCount !== channelCount) {\n          this.init(channelCount);\n        }\n        if (this.api && this.inputBuffer) {\n          // Feed\n          this.inputBuffer.write(inputs[0]);\n          this.api.inputSamples(this.inputBuffer.getPointer(), RENDER_QUANTUM_FRAMES);\n        }\n      }\n\n      // Just forward\n      var sourceLimit = Math.min(inputs.length, outputs.length);\n      var _loop = function _loop(inputNum) {\n        var input = inputs[inputNum];\n        var output = outputs[inputNum];\n        var channelCount = Math.min(input.length, output.length);\n        var _loop2 = function _loop2(channelNum) {\n          input[channelNum].forEach(function (sample, i) {\n            output[channelNum][i] = sample;\n          });\n        };\n        for (var channelNum = 0; channelNum < channelCount; channelNum++) {\n          _loop2(channelNum);\n        }\n      };\n      for (var inputNum = 0; inputNum < sourceLimit; inputNum++) {\n        _loop(inputNum);\n      }\n      return true;\n    }\n  }]);\n  return BpmCountProcessor;\n}( /*#__PURE__*/_wrapNativeSuper(AudioWorkletProcessor));\nregisterProcessor('bpm-count-processor', BpmCountProcessor);\n\n//# sourceURL=webpack://soundstretch-web/./src/worklet/bpm-count-processor.ts?");

/***/ }),

/***/ "./wasm/build/soundtouch.js":
/*!**********************************!*\
  !*** ./wasm/build/soundtouch.js ***!
  \**********************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return function (Module) {\n    Module = Module || {};\n    var Module = typeof Module != \"undefined\" ? Module : {};\n    var readyPromiseResolve, readyPromiseReject;\n    Module[\"ready\"] = new Promise(function (resolve, reject) {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    var moduleOverrides = Object.assign({}, Module);\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n    var quit_ = function quit_(status, toThrow) {\n      throw toThrow;\n    };\n    var ENVIRONMENT_IS_WEB = true;\n    var ENVIRONMENT_IS_WORKER = false;\n    var scriptDirectory = \"\";\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n    var read_, readAsync, readBinary, setWindowTitle;\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document != \"undefined\" && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n      {\n        read_ = function read_(url) {\n          try {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.send(null);\n            return xhr.responseText;\n          } catch (err) {\n            var data = tryParseAsDataURI(url);\n            if (data) {\n              return intArrayToString(data);\n            }\n            throw err;\n          }\n        };\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = function readBinary(url) {\n            try {\n              var xhr = new XMLHttpRequest();\n              xhr.open(\"GET\", url, false);\n              xhr.responseType = \"arraybuffer\";\n              xhr.send(null);\n              return new Uint8Array(xhr.response);\n            } catch (err) {\n              var data = tryParseAsDataURI(url);\n              if (data) {\n                return data;\n              }\n              throw err;\n            }\n          };\n        }\n        readAsync = function readAsync(url, onload, onerror) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onload = function () {\n            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n              onload(xhr.response);\n              return;\n            }\n            var data = tryParseAsDataURI(url);\n            if (data) {\n              onload(data.buffer);\n              return;\n            }\n            onerror();\n          };\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n      setWindowTitle = function setWindowTitle(title) {\n        return document.title = title;\n      };\n    } else {}\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.warn.bind(console);\n    Object.assign(Module, moduleOverrides);\n    moduleOverrides = null;\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\n    if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) != \"object\") {\n      abort(\"no native wasm support detected\");\n    }\n    var wasmMemory;\n    var ABORT = false;\n    var EXITSTATUS;\n    function assert(condition, text) {\n      if (!condition) {\n        abort(text);\n      }\n    }\n    var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n    function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) {\n        ++endPtr;\n      }\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = \"\";\n      while (idx < endPtr) {\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 128)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 224) == 192) {\n          str += String.fromCharCode((u0 & 31) << 6 | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 240) == 224) {\n          u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n        } else {\n          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n        }\n        if (u0 < 65536) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        }\n      }\n      return str;\n    }\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    }\n    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 192 | u >> 6;\n          heap[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 224 | u >> 12;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 240 | u >> 18;\n          heap[outIdx++] = 128 | u >> 12 & 63;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        }\n      }\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    }\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    }\n    function lengthBytesUTF8(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var c = str.charCodeAt(i);\n        if (c <= 127) {\n          len++;\n        } else if (c <= 2047) {\n          len += 2;\n        } else if (c >= 55296 && c <= 57343) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    }\n    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateGlobalBufferAndViews(buf) {\n      buffer = buf;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n    }\n    var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n    var wasmTable;\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    function addRunDependency(id) {\n      runDependencies++;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n    }\n    function removeRunDependency(id) {\n      runDependencies--;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    function abort(what) {\n      {\n        if (Module[\"onAbort\"]) {\n          Module[\"onAbort\"](what);\n        }\n      }\n      what = \"Aborted(\" + what + \")\";\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what += \". Build with -sASSERTIONS for more info.\";\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n    function isDataURI(filename) {\n      return filename.startsWith(dataURIPrefix);\n    }\n    var wasmBinaryFile;\n    wasmBinaryFile = \"data:application/octet-stream;base64,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AWoiAkEBa0EAOgAAIAFBA0kNACAAQQA6AAIgAEEAOgABIAJBA2tBADoAACACQQJrQQA6AAAgAUEHSQ0AIABBADoAAyACQQRrQQA6AAAgAUEJSQ0AIABBACAAa0EDcSIDaiICQQA2AgAgAiABIANrQXxxIgNqIgFBBGtBADYCACADQQlJDQAgAkEANgIIIAJBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIANBGUkNACACQQA2AhggAkEANgIUIAJBADYCECACQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAMgAkEEcUEYciIDayIBQSBJDQAgAiADaiECA0AgAkIANwMYIAJCADcDECACQgA3AwggAkIANwMAIAJBIGohAiABQSBrIgFBH0sNAAsLIAALugIBBH8jAEFAaiICJAAgACgCACIDQQRrKAIAIQQgA0EIaygCACEFIAJCADcCHCACQgA3AiQgAkIANwIsIAJCADcCNEEAIQMgAkEANgA7IAJCADcCFCACQZzDADYCECACIAA2AgwgAiABNgIIIAAgBWohAAJAIAQgAUEAEBUEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEMACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBELAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADC4AEAQN/IAJBgARPBEAgACABIAIQDSAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIABBA3FFBEAgACECDAELIAJFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICQQNxRQ0BIAIgA0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCAC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IAEgA0ECdCAEQQJ0QWBxaxAXGiAHCyMBAX8gAEGENzYCACAAKAIIIgEEQCABEBMLIABCADcCBCAACx4BAX8gAEGENzYCACAAKAIIIgEEQCABEBMLIAAQEws0AQF/IAEgACgCECICTwRAIABBADYCECACDwsgACACIAFrNgIQIAAgACgCGCABajYCGCABC0EBAX8gACgCECEDIAEgACAAKAIAKAIIEQAAIAMgAiACIANLGyIBIAAoAhRsQQJ0EBkaIAAgASAAKAIAKAIUEQIACxsAIAAgACgCECABahAWIAAgACgCECABajYCEAtAAQF/IAAgACgCECACahAWIAAoAgQgACgCFCIDIAAoAhBsQQJ0aiABIAIgA2xBAnQQGRogACAAKAIQIAJqNgIQCy8BAX8gACgCBCIBRQRAQbQbQekeQZYBQYckEAAACyABIAAoAhQgACgCGGxBAnRqCwcAIAAoAhALCAAgACgCEEULEAAgAEEANgIYIABBADYCEAsdAQF/IAEgACgCECICSQR/IAAgATYCECABBSACCwsWACAAKAIEIgAgASAAKAIAKAIUEQIACxgAIAAoAgQiACABIAIgACgCACgCEBEEAAsUACAAKAIEIgAgACgCACgCCBEAAAsUACAAKAIEIgAgACgCACgCGBEAAAsUACAAKAIEIgAgACgCACgCHBEAAAsWACAAKAIEIgAgASAAKAIAKAIkEQIACwgAIAAQNhATCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRCAALNQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRAQALOQEBfyABIAAoAgQiBEEBdWohASAAKAIAIQAgASACIAMgBEEBcQR/IAEoAgAgAGooAgAFIAALEQQACzsBAX8gASAAKAIEIgVBAXVqIQEgACgCACEAIAEgAiADIAQgBUEBcQR/IAEoAgAgAGooAgAFIAALEQYACzUBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAIAEgAkEBcQR/IAEoAgAgAGooAgAFIAALEQ8ACwcAIAAREAALJAEBf0HU4QAoAgAiAARAA0AgACgCABEJACAAKAIEIgANAAsLC4kBAEHE4QBBATYCAEHI4QBB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kYK8mIPJFuNg7z+sksHVUFqOPIUy2wPmae8/S2sBrFk6hDxgtAHzIXPvPx8+tAch1YK8X5t7M5d87z/JDUc7uSqJvCmh9RRGhu8/04g6YAS2dDz2P4vnLpDvP3FynVHsxYM8g0zH+1Ga7z/wkdOPEvePvNqQpKKvpO8/fXQj4piujbzxZ44tSK/vPwggqkG8w448J1ph7hu67z8y66nDlCuEPJe6azcrxe8/7oXRMalkijxARW5bdtDvP+3jO+S6N468FL6crf3b7z+dzZFNO4l3PNiQnoHB5+8/icxgQcEFUzzxcY8rwvPvP3Vuc2lnbmVkIHNob3J0AHdpbmRvd0xlbiA+IHdpbmRvd1N0YXJ0AGdldENoYW5uZWxDb3VudAB1bnNpZ25lZCBpbnQAQlBNRGV0ZWN0AGZsb2F0AHVpbnQ2NF90AHNldENvZWZmaWNpZW50cwBnZXRCZWF0cwBncDEgPT0gcGVha3BvcwB1cGRhdGVCZWF0UG9zAEVycm9yOiBJbGxlZ2FsIG51bWJlciBvZiBjaGFubmVscwBjYWxjdWxhdGVDb2VmZnMAc2V0UGl0Y2hTZW1pVG9uZXMAaW5wdXRTYW1wbGVzAHByb2Nlc3NTYW1wbGVzAHVwZGF0ZVhDb3JyAHZlY3RvcgBCUE1EZXRlY3RvcgBnZXRQZWFrQ2VudGVyAHBBQUZpbHRlcgBvdXRwdXQgPT0gcFJhdGVUcmFuc3Bvc2VyAGJ1ZmZlcgB1bnNpZ25lZCBjaGFyAC9Vc2Vycy90b2JpYXMvRGV2ZWxvcGVyL2JlY2hzdGVpbi9zb3VuZHN0cmV0Y2gtd2ViL3dhc20vbGliL3NvdW5kdG91Y2gvc291cmNlL1NvdW5kVG91Y2gvQlBNRGV0ZWN0LmNwcAAvVXNlcnMvdG9iaWFzL0RldmVsb3Blci9iZWNoc3RlaW4vc291bmRzdHJldGNoLXdlYi93YXNtL2xpYi9zb3VuZHRvdWNoL3NvdXJjZS9Tb3VuZFRvdWNoL0ZJUkZpbHRlci5jcHAAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9zb3VyY2UvU291bmRUb3VjaC9BQUZpbHRlci5jcHAAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9zb3VyY2UvU291bmRUb3VjaC9SYXRlVHJhbnNwb3Nlci5jcHAAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9zb3VyY2UvU291bmRUb3VjaC9GSUZPU2FtcGxlQnVmZmVyLmNwcAAvVXNlcnMvdG9iaWFzL0RldmVsb3Blci9iZWNoc3RlaW4vc291bmRzdHJldGNoLXdlYi93YXNtL2xpYi9zb3VuZHRvdWNoL3NvdXJjZS9Tb3VuZFRvdWNoL1BlYWtGaW5kZXIuY3BwAC9Vc2Vycy90b2JpYXMvRGV2ZWxvcGVyL2JlY2hzdGVpbi9zb3VuZHN0cmV0Y2gtd2ViL3dhc20vbGliL3NvdW5kdG91Y2gvc291cmNlL1NvdW5kVG91Y2gvU291bmRUb3VjaC5jcHAAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9zb3VyY2UvU291bmRUb3VjaC9URFN0cmV0Y2guY3BwAC9Vc2Vycy90b2JpYXMvRGV2ZWxvcGVyL2JlY2hzdGVpbi9zb3VuZHN0cmV0Y2gtd2ViL3dhc20vbGliL3NvdW5kdG91Y2gvc291cmNlL1NvdW5kVG91Y2gvSW50ZXJwb2xhdGVDdWJpYy5jcHAAb3ZlcmxhcABzZXRUZW1wbwBjYWxjRWZmZWN0aXZlUmF0ZUFuZFRlbXBvAGV2YWx1YXRlRmlsdGVyTW9ubwB0cmFuc3Bvc2VNb25vAGV2YWx1YXRlRmlsdGVyU3RlcmVvAHRyYW5zcG9zZVN0ZXJlbwBzdGQ6OmV4Y2VwdGlvbgBnZXRWZXJzaW9uAHB0ckJlZ2luAGdldEJwbQBib29sAHB1bGwAcGVha2xldmVsID49IGxldmVsAGZpbmRDcm9zc2luZ0xldmVsAGVtc2NyaXB0ZW46OnZhbABldmFsdWF0ZUZpbHRlck11bHRpAHRyYW5zcG9zZU11bHRpAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGxlbmd0aERpdjggKiA4ID09IGxlbmd0aABsZW5ndGggPT0gbmV3TGVuZ3RoAGNhbGN1bGF0ZU92ZXJsYXBMZW5ndGgAcHVzaABmbHVzaABzZXRQaXRjaABTb3VuZFN0cmV0Y2gAb3V0cHV0ID09IHBURFN0cmV0Y2gAL1VzZXJzL3RvYmlhcy9EZXZlbG9wZXIvYmVjaHN0ZWluL3NvdW5kc3RyZXRjaC13ZWIvd2FzbS9saWIvc291bmR0b3VjaC9pbmNsdWRlL0ZJRk9TYW1wbGVQaXBlLmgAdW5zaWduZWQgbG9uZwBzdGQ6OndzdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAZXZhbHVhdGUAVG9vIHNtYWxsIHNhbXBsZXJhdGUARXJyb3I6IEV4Y2Vzc2l2ZSBzYW1wbGVyYXRlAGRlY2ltYXRlAHNldFJhdGUAdHJhbnNwb3NlAHNldE91dFBpcGUAZG91YmxlAGF2YWlsYWJsZQB2b2lkAFNvdW5kVG91Y2ggOiBOdW1iZXIgb2YgY2hhbm5lbHMgbm90IGRlZmluZWQAU291bmRUb3VjaCA6IFNhbXBsZSByYXRlIG5vdCBkZWZpbmVkAHN0ZDo6YmFkX2FsbG9jAG91dHB1dCA9PSBOVUxMAGRlc3QgIT0gTlVMTABmaWx0ZXJDb2VmZnMgIT0gTlVMTABzcmMgIT0gTlVMTABlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AEZJUiBmaWx0ZXIgbGVuZ3RoIG5vdCBkaXZpc2libGUgYnkgOAB0ZW1wID49IC0zMjc2OCAmJiB0ZW1wIDw9IDMyNzY3AG51bUNoYW5uZWxzIDwgMTYAd29ya1tsZW5ndGgvMiAtIDFdID4gLTFlLTYAd29ya1tsZW5ndGgvMiArIDFdID4gLTFlLTYAY3V0b2ZmRnJlcSA8PSAwLjUAbGVuZ3RoID49IDIAZnJhY3QgPCAxLjAAZGVjaW1hdGVCeSA+IDAAY2hhbm5lbHMgPiAwAG51bUNoYW5uZWxzID4gMABzdW0gPiAwAGxlbmd0aCA+IDAAbmV3TGVuZ3RoID4gMAB3b3JrW2xlbmd0aC8yXSA+IDAAY3V0b2ZmRnJlcSA+PSAwAG92ZXJsYXBJbk1zZWMgPj0gMABsZW5ndGggJSA0ID09IDAAZGVjaW1hdGVCeSAhPSAwAGlsZW5ndGggIT0gMABidWZmZXItPm51bVNhbXBsZXMoKSA+PSAodWludCkocHJvY2Vzc19zYW1wbGVzICsgd2luZG93TGVuKQAobGVuZ3RoICE9IDApICYmIChsZW5ndGggPT0gaWxlbmd0aCkgJiYgKHNyYyAhPSBOVUxMKSAmJiAoZGVzdCAhPSBOVUxMKSAmJiAoZmlsdGVyQ29lZmZzICE9IE5VTEwpAG51bUNoYW5uZWxzID09IGRlc3QuZ2V0Q2hhbm5lbHMoKQAob2Zmc2V0ICsgdGVtcCArIG92ZXJsYXBMZW5ndGgpIDw9IChpbnQpaW5wdXRCdWZmZXIubnVtU2FtcGxlcygpADEyU291bmRTdHJldGNoAAAAICUAAIcZAABQMTJTb3VuZFN0cmV0Y2gA9CMAAKAZAAAAAAAAmBkAAFBLMTJTb3VuZFN0cmV0Y2gAAAAA9CMAAMAZAAABAAAAmBkAAGlpAHYAdmkAsBkAAIAjAACAIwAAaWlpaQAAAACAIwAAgCMAALAZAABpaWkA/CIAALAZAACwIwAAdmlpZAAAAACAIwAA1BkAAAAAAACAIwAAsBkAAIAjAACAIwAAaWlpaWkAAAD8IgAAsBkAAHZpaQBB4DQLdvwiAACwGQAAgCMAAIAjAAB2aWlpaQAxMUJQTURldGVjdG9yACAlAAB2GgAAUDExQlBNRGV0ZWN0b3IAAPQjAACMGgAAAAAAAIQaAABQSzExQlBNRGV0ZWN0b3IA9CMAAKwaAAABAAAAhBoAAJwaAABcIwAAXCMAQeA1C5cr/CIAAJwaAACAIwAAXCMAAKQjAACcGgAAZmlpAAAAAABcIwAAnBoAAIAjAACAIwAAXCMAAGlpaWlpaQAAAAAAAHQbAAAmAAAAJwAAAAAAAABhzhk5WGmEP4em8Gt36ZO/Yc4ZOVhphD9F31V3sn//P8kHFfVjA++/TjEwc291bmR0b3VjaDlCUE1EZXRlY3RFAAAAACAlAABYGwAAAAAAANQbAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAAE4xMHNvdW5kdG91Y2gxNkZJRk9TYW1wbGVCdWZmZXJFAAAAAGAlAACwGwAAFB4AAAAAAAAcHAAAMwAAADQAAAA1AAAANgAAADcAAAA4AAAATjEwc291bmR0b3VjaDlGSVJGaWx0ZXJFAAAAACAlAAAAHAAAAAAAAHgcAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAATjEwc291bmR0b3VjaDE2SW50ZXJwb2xhdGVDdWJpY0UAAAAAYCUAAFQcAAAEHQAAAAAAANgcAABDAAAARAAAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAAE4xMHNvdW5kdG91Y2gxNFJhdGVUcmFuc3Bvc2VyRQAAYCUAALgcAAAcHgAATjEwc291bmR0b3VjaDE0VHJhbnNwb3NlckJhc2VFAAAgJQAA5BwAAAAAAABcHQAATgAAAE8AAABFAAAAUAAAAFEAAABSAAAASQAAAFMAAABUAAAATAAAAFUAAABOMTBzb3VuZHRvdWNoMTBTb3VuZFRvdWNoRQAAYCUAAEAdAAAcHgAAAAAAACgeAABWAAAAVwAAAEUAAABYAAAARwAAAEgAAABJAAAAUwAAAFkAAABMAAAAWgAAAFsAAABcAAAAXQAAAF4AAABfAAAAYAAAAGEAAABiAAAATjEwc291bmR0b3VjaDlURFN0cmV0Y2hFAE4xMHNvdW5kdG91Y2gxM0ZJRk9Qcm9jZXNzb3JFAE4xMHNvdW5kdG91Y2gxNEZJRk9TYW1wbGVQaXBlRQAAACAlAADzHQAAYCUAANUdAAAUHgAAYCUAALwdAAAcHgAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAACAlAAA0HgAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAACAlAAB8HgAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAACAlAADEHgAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAAAgJQAADB8AAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAICUAAFgfAABOMTBlbXNjcmlwdGVuM3ZhbEUAACAlAACkHwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAAAgJQAAwB8AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAICUAAOgfAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAACAlAAAQIAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAAgJQAAOCAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAAICUAAGAgAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAACAlAACIIAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAAgJQAAsCAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAAICUAANggAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAACAlAAAAIQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAAAgJQAAKCEAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAAICUAAFAhAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAABgJQAAeCEAAFAlAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAABgJQAAqCEAAJwhAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAABgJQAA2CEAAJwhAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBgJQAACCIAAPwhAABOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UAAAAAYCUAADgiAACcIQAATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAAAAYCUAAGwiAAD8IQAAAAAAAOwiAABjAAAAZAAAAGUAAABmAAAAZwAAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQBgJQAAxCIAAJwhAAB2AAAAsCIAAPgiAABEbgAAsCIAAAQjAABiAAAAsCIAABAjAABjAAAAsCIAABwjAABoAAAAsCIAACgjAABhAAAAsCIAADQjAABzAAAAsCIAAEAjAAB0AAAAsCIAAEwjAABpAAAAsCIAAFgjAABqAAAAsCIAAGQjAABsAAAAsCIAAHAjAABtAAAAsCIAAHwjAAB4AAAAsCIAAIgjAAB5AAAAsCIAAJQjAABmAAAAsCIAAKAjAABkAAAAsCIAAKwjAABOMTBfX2N4eGFiaXYxMjBfX3NpX2NsYXNzX3R5cGVfaW5mb0UAAAAAYCUAALgjAADMIQAAAAAAACwiAABjAAAAaAAAAGUAAABmAAAAaQAAAAAAAABMJAAAIwAAAGoAAABrAAAAAAAAAHQkAAAjAAAAbAAAAG0AAABTdDlleGNlcHRpb24AU3Q5YmFkX2FsbG9jAAAAYCUAAD0kAACAJQAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAGAlAABYJAAATCQAAAAAAAC4JAAAJAAAAG4AAABvAAAAAAAAAAwlAAAiAAAAcAAAAHEAAABTdDExbG9naWNfZXJyb3IAYCUAAKgkAACAJQAAAAAAAOwkAAAkAAAAcgAAAG8AAABTdDEybGVuZ3RoX2Vycm9yAAAAAGAlAADYJAAAuCQAAFN0MTNydW50aW1lX2Vycm9yAAAAYCUAAPgkAACAJQAAAAAAAMwhAABjAAAAcwAAAGUAAABmAAAAdAAAAHUAAAB2AAAAdwAAAFN0OXR5cGVfaW5mbwAAAAAgJQAAQCUAAAAAAADgIwAAYwAAAHgAAABlAAAAZgAAAHQAAAB5AAAAegAAAHsAAAAgJQAAMCQAAAAAAACAJQAAIwAAAHwAAAB9AAAAAAAAAAMAAAAEAAAABAAAAAYAAACD+aIARE5uAPwpFQDRVycA3TT1AGLbwAA8mZUAQZBDAGNR/gC73qsAt2HFADpuJADSTUIASQbgAAnqLgAcktEA6x3+ACmxHADoPqcA9TWCAES7LgCc6YQAtCZwAEF+XwDWkTkAU4M5AJz0OQCLX4QAKPm9APgfOwDe/5cAD5gFABEv7wAKWosAbR9tAM9+NgAJyycARk+3AJ5mPwAt6l8Auid1AOXrxwA9e/EA9zkHAJJSigD7a+oAH7FfAAhdjQAwA1YAe/xGAPCrawAgvM8ANvSaAOOpHQBeYZEACBvmAIWZZQCgFF8AjUBoAIDY/wAnc00ABgYxAMpWFQDJqHMAe+JgAGuMwAAZxEcAzWfDAAno3ABZgyoAi3bEAKYclgBEr90AGVfRAKU+BQAFB/8AM34/AMIy6ACYT94Au30yACY9wwAea+8An/heADUfOgB/8soA8YcdAHyQIQBqJHwA1W76ADAtdwAVO0MAtRTGAMMZnQCtxMIALE1BAAwAXQCGfUYA43EtAJvGmgAzYgAAtNJ8ALSnlwA3VdUA1z72AKMQGABNdvwAZJ0qAHDXqwBjfPgAerBXABcV5wDASVYAO9bZAKeEOAAkI8sA1op3AFpUIwAAH7kA8QobABnO3wCfMf8AZh5qAJlXYQCs+0cAfn/YACJltwAy6IkA5r9gAO/EzQBsNgkAXT/UABbe1wBYO94A3puSANIiKAAohugA4lhNAMbKMgAI4xYA4H3LABfAUADzHacAGOBbAC4TNACDEmIAg0gBAPWOWwCtsH8AHunyAEhKQwAQZ9MAqt3YAK5fQgBqYc4ACiikANOZtAAGpvIAXHd/AKPCgwBhPIgAinN4AK+MWgBv170ALaZjAPS/ywCNge8AJsFnAFXKRQDK2TYAKKjSAMJhjQASyXcABCYUABJGmwDEWcQAyMVEAE2ykQAAF/MA1EOtAClJ5QD91RAAAL78AB6UzABwzu4AEz71AOzxgACz58MAx/goAJMFlADBcT4ALgmzAAtF8wCIEpwAqyB7AC61nwBHksIAezIvAAxVbQByp5AAa+cfADHLlgB5FkoAQXniAPTfiQDolJcA4uaEAJkxlwCI7WsAX182ALv9DgBImrQAZ6RsAHFyQgCNXTIAnxW4ALzlCQCNMSUA93Q5ADAFHAANDAEASwhoACzuWABHqpAAdOcCAL3WJAD3faYAbkhyAJ8W7wCOlKYAtJH2ANFTUQDPCvIAIJgzAPVLfgCyY2gA3T5fAEBdAwCFiX8AVVIpADdkwABt2BAAMkgyAFtMdQBOcdQARVRuAAsJwQAq9WkAFGbVACcHnQBdBFAAtDvbAOp2xQCH+RcASWt9AB0nugCWaSkAxsysAK0UVACQ4moAiNmJACxyUAAEpL4AdweUAPMwcAAA/CcA6nGoAGbCSQBk4D0Al92DAKM/lwBDlP0ADYaMADFB3gCSOZ0A3XCMABe35wAI3zsAFTcrAFyAoABagJMAEBGSAA/o2ABsgK8A2/9LADiQDwBZGHYAYqUVAGHLuwDHibkAEEC9ANLyBABJdScA67b2ANsiuwAKFKoAiSYvAGSDdgAJOzMADpQaAFE6qgAdo8IAr+2uAFwmEgBtwk0ALXqcAMBWlwADP4MACfD2ACtAjABtMZkAObQHAAwgFQDYw1sA9ZLEAMatSwBOyqUApzfNAOapNgCrkpQA3UJoABlj3gB2jO8AaItSAPzbNwCuoasA3xUxAACuoQAM+9oAZE1mAO0FtwApZTAAV1a/AEf/OgBq+bkAdb7zACiT3wCrgDAAZoz2AATLFQD6IgYA2eQdAD2zpABXG48ANs0JAE5C6QATvqQAMyO1APCqGgBPZagA0sGlAAs/DwBbeM0AI/l2AHuLBACJF3IAxqZTAG9u4gDv6wAAm0pYAMTatwCqZroAds/PANECHQCx8S0AjJnBAMOtdwCGSNoA912gAMaA9ACs8C8A3eyaAD9cvADQ3m0AkMcfACrbtgCjJToAAK+aAK1TkwC2VwQAKS20AEuAfgDaB6cAdqoOAHtZoQAWEioA3LctAPrl/QCJ2/4Aib79AOR2bAAGqfwAPoBwAIVuFQD9h/8AKD4HAGFnMwAqGIYATb3qALPnrwCPbW4AlWc5ADG/WwCE10gAMN8WAMctQwAlYTUAyXDOADDLuAC/bP0ApACiAAVs5ABa3aAAIW9HAGIS0gC5XIQAcGFJAGtW4ACZUgEAUFU3AB7VtwAz8cQAE25fAF0w5ACFLqkAHbLDAKEyNgAIt6QA6rHUABb3IQCPaeQAJ/93AAwDgACNQC0AT82gACClmQCzotMAL10KALT5QgAR2ssAfb7QAJvbwQCrF70AyqKBAAhqXAAuVRcAJwBVAH8U8ADhB4YAFAtkAJZBjQCHvt4A2v0qAGsltgB7iTQABfP+ALm/ngBoak8ASiqoAE/EWgAt+LwA11qYAPTHlQANTY0AIDqmAKRXXwAUP7EAgDiVAMwgAQBx3YYAyd62AL9g9QBNZREAAQdrAIywrACywNAAUVVIAB77DgCVcsMAowY7AMBANQAG3HsA4EXMAE4p+gDWysgA6PNBAHxk3gCbZNgA2b4xAKSXwwB3WNQAaePFAPDaEwC6OjwARhhGAFV1XwDSvfUAbpLGAKwuXQAORO0AHD5CAGHEhwAp/ekA59bzACJ8ygBvkTUACODFAP/XjQBuauIAsP3GAJMIwQB8XXQAa62yAM1unQA+cnsAxhFqAPfPqQApc98Atcm6ALcAUQDisg0AdLokAOV9YAB02IoADRUsAIEYDAB+ZpQAASkWAJ96dgD9/b4AVkXvANl+NgDs2RMAi7q5AMSX/AAxqCcA8W7DAJTFNgDYqFYAtKi1AM/MDgASiS0Ab1c0ACxWiQCZzuMA1iC5AGteqgA+KpwAEV/MAP0LSgDh9PsAjjttAOKGLADp1IQA/LSpAO/u0QAuNckALzlhADghRAAb2cgAgfwKAPtKagAvHNgAU7SEAE6ZjABUIswAKlXcAMDG1gALGZYAGnC4AGmVZAAmWmAAP1LuAH8RDwD0tREA/Mv1ADS8LQA0vO4A6F3MAN1eYABnjpsAkjPvAMkXuABhWJsA4Ve8AFGDxgDYPhAA3XFIAC0c3QCvGKEAISxGAFnz1wDZepgAnlTAAE+G+gBWBvwA5XmuAIkiNgA4rSIAZ5PcAFXoqgCCJjgAyuebAFENpACZM7EAqdcOAGkFSABlsvAAf4inAIhMlwD50TYAIZKzAHuCSgCYzyEAQJ/cANxHVQDhdDoAZ+tCAP6d3wBe1F8Ae2ekALqsegBV9qIAK4gjAEG6VQBZbggAISqGADlHgwCJ4+YA5Z7UAEn7QAD/VukAHA/KAMVZigCU+isA08HFAA/FzwDbWq4AR8WGAIVDYgAhhjsALHmUABBhhwAqTHsAgCwaAEO/EgCIJpAAeDyJAKjE5ADl23sAxDrCACb06gD3Z4oADZK/AGWjKwA9k7EAvXwLAKRR3AAn3WMAaeHdAJqUGQCoKZUAaM4oAAnttABEnyAATpjKAHCCYwB+fCMAD7kyAKf1jgAUVucAIfEIALWdKgBvfk0ApRlRALX5qwCC39YAlt1hABY2AgDEOp8Ag6KhAHLtbQA5jXoAgripAGsyXABGJ1sAADTtANIAdwD89FUAAVlNAOBxgABBg+EACz1A+yH5PwAAAAAtRHQ+AAAAgJhG+DwAAABgUcx4OwAAAICDG/A5AAAAQCAlejgAAACAIoLjNgAAAAAd82k1AEHA4QALA+AyUAD3SgRuYW1lAZxKpwEADV9fYXNzZXJ0X2ZhaWwBHF9lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcCH19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24DGF9lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcgQLX19jeGFfdGhyb3cFGF9fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbgYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAccX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZwgbX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nCRZfZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0CiJfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yCxZfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzDCNsZWdhbGltcG9ydCRfZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludA0VZW1zY3JpcHRlbl9tZW1jcHlfYmlnDgVhYm9ydA8VX2VtYmluZF9yZWdpc3Rlcl92b2lkEBZfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsESVfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NsYXNzX2Z1bmN0aW9uEhVfZW1iaW5kX3JlZ2lzdGVyX2Jvb2wTBmRsZnJlZRQbb3BlcmF0b3IgbmV3KHVuc2lnbmVkIGxvbmcpFTxpc19lcXVhbChzdGQ6OnR5cGVfaW5mbyBjb25zdCosIHN0ZDo6dHlwZV9pbmZvIGNvbnN0KiwgYm9vbCkWOnNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXI6OmVuc3VyZUNhcGFjaXR5KHVuc2lnbmVkIGludCkXBm1lbXNldBgOX19keW5hbWljX2Nhc3QZCF9fbWVtY3B5GhhvcGVyYXRvciBkZWxldGVbXSh2b2lkKikbLnN0ZDo6cnVudGltZV9lcnJvcjo6cnVudGltZV9lcnJvcihjaGFyIGNvbnN0KikcB21lbW1vdmUdM3NvdW5kdG91Y2g6OlNvdW5kVG91Y2g6OmNhbGNFZmZlY3RpdmVSYXRlQW5kVGVtcG8oKR4Gc2NhbGJuHwRzYnJrIANjb3MhBV9fc2luIgVfX2NvcyMjc3RkOjpfX3Rocm93X2JhZF9hcnJheV9uZXdfbGVuZ3RoKCkkFVNvdW5kU3RyZXRjaDo6Y2xlYXIoKSUcc3RkOjpleGNlcHRpb246On5leGNlcHRpb24oKSY4c291bmR0b3VjaDo6VERTdHJldGNoOjpzZXRQYXJhbWV0ZXJzKGludCwgaW50LCBpbnQsIGludCknLHNvdW5kdG91Y2g6OlREU3RyZXRjaDo6Y2xlYXJDcm9zc0NvcnJTdGF0ZSgpKD5zb3VuZHRvdWNoOjpQZWFrRmluZGVyOjpnZXRQZWFrQ2VudGVyKGZsb2F0IGNvbnN0KiwgaW50KSBjb25zdCkGbWFsbG9jKgVsZGV4cCsGc3RybGVuLCRzdGQ6OnJ1bnRpbWVfZXJyb3I6On5ydW50aW1lX2Vycm9yKCktInN0ZDo6bG9naWNfZXJyb3I6On5sb2dpY19lcnJvcigpLjEuIHN0ZDo6bG9naWNfZXJyb3I6On5sb2dpY19lcnJvcigpLx5zdGQ6OmxvZ2ljX2Vycm9yOjp3aGF0KCkgY29uc3QwQ3N0ZDo6X18yOjpkZXF1ZTxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+OjpzaHJpbmtfdG9fZml0KCkxiQFzdGQ6Ol9fMjo6X19zcGxpdF9idWZmZXI8ZmxvYXQqLCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Kj4+OjpvcGVyYXRvcj0oc3RkOjpfXzI6Ol9fc3BsaXRfYnVmZmVyPGZsb2F0Kiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdCo+PiYmKTIzc3RkOjpfXzI6Ol9fbGliY3BwX3JlZnN0cmluZzo6fl9fbGliY3BwX3JlZnN0cmluZygpMz1zdGQ6Ol9fMjo6X19saWJjcHBfcmVmc3RyaW5nOjpfX2xpYmNwcF9yZWZzdHJpbmcoY2hhciBjb25zdCopNB9zb3VuZHRvdWNoOjpTb3VuZFRvdWNoOjpmbHVzaCgpNS9zb3VuZHRvdWNoOjpSYXRlVHJhbnNwb3Nlcjo6flJhdGVUcmFuc3Bvc2VyKCkuMTYlc291bmR0b3VjaDo6QlBNRGV0ZWN0Ojp+QlBNRGV0ZWN0KCkuMTdic291bmR0b3VjaDo6QUFGaWx0ZXI6OmV2YWx1YXRlKHNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXImLCBzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyJikgY29uc3Q4J3NvdW5kdG91Y2g6OkFBRmlsdGVyOjpjYWxjdWxhdGVDb2VmZnMoKTkhbGVnYWxmdW5jJF9lbWJpbmRfcmVnaXN0ZXJfYmlnaW50Ov4BZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8dm9pZCAoU291bmRTdHJldGNoOjoqKSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKSwgdm9pZCwgU291bmRTdHJldGNoKiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz46Omludm9rZSh2b2lkIChTb3VuZFN0cmV0Y2g6OiogY29uc3QmKSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKSwgU291bmRTdHJldGNoKiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZyk7pQFlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjx1bnNpZ25lZCBsb25nIChTb3VuZFN0cmV0Y2g6OiopKCksIHVuc2lnbmVkIGxvbmcsIFNvdW5kU3RyZXRjaCo+OjppbnZva2UodW5zaWduZWQgbG9uZyAoU291bmRTdHJldGNoOjoqIGNvbnN0JikoKSwgU291bmRTdHJldGNoKik8qQFlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxTb3VuZFN0cmV0Y2gqLCB1bnNpZ25lZCBsb25nJiYsIHVuc2lnbmVkIGxvbmcmJj46Omludm9rZShTb3VuZFN0cmV0Y2gqICgqKSh1bnNpZ25lZCBsb25nJiYsIHVuc2lnbmVkIGxvbmcmJiksIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcpPRVlbWJpbmRfaW5pdF9idWlsdGluKCk+IGVtYmluZF9pbml0X0NMQVNTX1NvdW5kU3RyZXRjaCgpPx9lbWJpbmRfaW5pdF9DTEFTU19CUE1EZXRlY3RvcigpQApfX3JlbV9waW8yQWZfX2N4eGFiaXYxOjpfX3BvaW50ZXJfdG9fbWVtYmVyX3R5cGVfaW5mbzo6Y2FuX2NhdGNoX25lc3RlZChfX2N4eGFiaXYxOjpfX3NoaW1fdHlwZV9pbmZvIGNvbnN0KikgY29uc3RCgwFfX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6cHJvY2Vzc19zdGF0aWNfdHlwZV9hYm92ZV9kc3QoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQgY29uc3QqLCB2b2lkIGNvbnN0KiwgaW50KSBjb25zdENrX19jeHhhYml2MTo6X19jbGFzc190eXBlX2luZm86OnByb2Nlc3NfZm91bmRfYmFzZV9jbGFzcyhfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCosIGludCkgY29uc3REFlNvdW5kU3RyZXRjaDo6YnVmZmVyKClFRnZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJhd19kZXN0cnVjdG9yPFNvdW5kU3RyZXRjaD4oU291bmRTdHJldGNoKilGRHZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJhd19kZXN0cnVjdG9yPEJQTURldGVjdG9yPihCUE1EZXRlY3RvciopR0x2b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0QWN0dWFsVHlwZTxTb3VuZFN0cmV0Y2g+KFNvdW5kU3RyZXRjaCopSEp2b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0QWN0dWFsVHlwZTxCUE1EZXRlY3Rvcj4oQlBNRGV0ZWN0b3IqKUkmc3RkOjpydW50aW1lX2Vycm9yOjp+cnVudGltZV9lcnJvcigpLjFKHHN0ZDo6ZXhjZXB0aW9uOjp3aGF0KCkgY29uc3RLJ3N0ZDo6YmFkX2FycmF5X25ld19sZW5ndGg6OndoYXQoKSBjb25zdEwcc3RkOjpiYWRfYWxsb2M6OndoYXQoKSBjb25zdE1jc291bmR0b3VjaDo6VHJhbnNwb3NlckJhc2U6OnRyYW5zcG9zZShzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyJiwgc291bmR0b3VjaDo6RklGT1NhbXBsZUJ1ZmZlciYpTitzb3VuZHRvdWNoOjpUcmFuc3Bvc2VyQmFzZTo6c2V0UmF0ZShkb3VibGUpTyxzb3VuZHRvdWNoOjpUcmFuc3Bvc2VyQmFzZTo6c2V0Q2hhbm5lbHMoaW50KVAlc291bmR0b3VjaDo6VERTdHJldGNoOjp+VERTdHJldGNoKCkuMVEjc291bmR0b3VjaDo6VERTdHJldGNoOjp+VERTdHJldGNoKClSPHNvdW5kdG91Y2g6OlREU3RyZXRjaDo6c2Vla0Jlc3RPdmVybGFwUG9zaXRpb24oZmxvYXQgY29uc3QqKVNBc291bmR0b3VjaDo6VERTdHJldGNoOjpzZWVrQmVzdE92ZXJsYXBQb3NpdGlvblF1aWNrKGZsb2F0IGNvbnN0KilUQHNvdW5kdG91Y2g6OlREU3RyZXRjaDo6c2Vla0Jlc3RPdmVybGFwUG9zaXRpb25GdWxsKGZsb2F0IGNvbnN0KilVPXNvdW5kdG91Y2g6OlREU3RyZXRjaDo6cHV0U2FtcGxlcyhmbG9hdCBjb25zdCosIHVuc2lnbmVkIGludClWQHNvdW5kdG91Y2g6OlREU3RyZXRjaDo6b3ZlcmxhcFN0ZXJlbyhmbG9hdCosIGZsb2F0IGNvbnN0KikgY29uc3RXP3NvdW5kdG91Y2g6OlREU3RyZXRjaDo6b3ZlcmxhcE11bHRpKGZsb2F0KiwgZmxvYXQgY29uc3QqKSBjb25zdFg+c291bmR0b3VjaDo6VERTdHJldGNoOjpvdmVybGFwTW9ubyhmbG9hdCosIGZsb2F0IGNvbnN0KikgY29uc3RZHnNvdW5kdG91Y2g6OlREU3RyZXRjaDo6Y2xlYXIoKVpJc291bmR0b3VjaDo6VERTdHJldGNoOjpjYWxjQ3Jvc3NDb3JyKGZsb2F0IGNvbnN0KiwgZmxvYXQgY29uc3QqLCBkb3VibGUmKVtTc291bmR0b3VjaDo6VERTdHJldGNoOjpjYWxjQ3Jvc3NDb3JyQWNjdW11bGF0ZShmbG9hdCBjb25zdCosIGZsb2F0IGNvbnN0KiwgZG91YmxlJilcJ3NvdW5kdG91Y2g6OlNvdW5kVG91Y2g6On5Tb3VuZFRvdWNoKCkuMV0lc291bmR0b3VjaDo6U291bmRUb3VjaDo6flNvdW5kVG91Y2goKV40c291bmR0b3VjaDo6U291bmRUb3VjaDo6cmVjZWl2ZVNhbXBsZXModW5zaWduZWQgaW50KV88c291bmR0b3VjaDo6U291bmRUb3VjaDo6cmVjZWl2ZVNhbXBsZXMoZmxvYXQqLCB1bnNpZ25lZCBpbnQpYD5zb3VuZHRvdWNoOjpTb3VuZFRvdWNoOjpwdXRTYW1wbGVzKGZsb2F0IGNvbnN0KiwgdW5zaWduZWQgaW50KWE1c291bmR0b3VjaDo6U291bmRUb3VjaDo6bnVtVW5wcm9jZXNzZWRTYW1wbGVzKCkgY29uc3RiH3NvdW5kdG91Y2g6OlNvdW5kVG91Y2g6OmNsZWFyKCljLXNvdW5kdG91Y2g6OlJhdGVUcmFuc3Bvc2VyOjp+UmF0ZVRyYW5zcG9zZXIoKWQrc291bmR0b3VjaDo6UmF0ZVRyYW5zcG9zZXI6OnNldFJhdGUoZG91YmxlKWVCc291bmR0b3VjaDo6UmF0ZVRyYW5zcG9zZXI6OnB1dFNhbXBsZXMoZmxvYXQgY29uc3QqLCB1bnNpZ25lZCBpbnQpZitzb3VuZHRvdWNoOjpSYXRlVHJhbnNwb3Nlcjo6aXNFbXB0eSgpIGNvbnN0ZyNzb3VuZHRvdWNoOjpSYXRlVHJhbnNwb3Nlcjo6Y2xlYXIoKWhJc291bmR0b3VjaDo6SW50ZXJwb2xhdGVDdWJpYzo6dHJhbnNwb3NlU3RlcmVvKGZsb2F0KiwgZmxvYXQgY29uc3QqLCBpbnQmKWlIc291bmR0b3VjaDo6SW50ZXJwb2xhdGVDdWJpYzo6dHJhbnNwb3NlTXVsdGkoZmxvYXQqLCBmbG9hdCBjb25zdCosIGludCYpakdzb3VuZHRvdWNoOjpJbnRlcnBvbGF0ZUN1YmljOjp0cmFuc3Bvc2VNb25vKGZsb2F0KiwgZmxvYXQgY29uc3QqLCBpbnQmKWsuc291bmR0b3VjaDo6SW50ZXJwb2xhdGVDdWJpYzo6cmVzZXRSZWdpc3RlcnMoKWwwc291bmR0b3VjaDo6SW50ZXJwb2xhdGVDdWJpYzo6Z2V0TGF0ZW5jeSgpIGNvbnN0bSVzb3VuZHRvdWNoOjpGSVJGaWx0ZXI6On5GSVJGaWx0ZXIoKS4xbiNzb3VuZHRvdWNoOjpGSVJGaWx0ZXI6On5GSVJGaWx0ZXIoKW9Qc291bmR0b3VjaDo6RklSRmlsdGVyOjpzZXRDb2VmZmljaWVudHMoZmxvYXQgY29uc3QqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludClwVXNvdW5kdG91Y2g6OkZJUkZpbHRlcjo6ZXZhbHVhdGVGaWx0ZXJTdGVyZW8oZmxvYXQqLCBmbG9hdCBjb25zdCosIHVuc2lnbmVkIGludCkgY29uc3RxXHNvdW5kdG91Y2g6OkZJUkZpbHRlcjo6ZXZhbHVhdGVGaWx0ZXJNdWx0aShmbG9hdCosIGZsb2F0IGNvbnN0KiwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQpclNzb3VuZHRvdWNoOjpGSVJGaWx0ZXI6OmV2YWx1YXRlRmlsdGVyTW9ubyhmbG9hdCosIGZsb2F0IGNvbnN0KiwgdW5zaWduZWQgaW50KSBjb25zdHMzc291bmR0b3VjaDo6RklGT1NhbXBsZUJ1ZmZlcjo6fkZJRk9TYW1wbGVCdWZmZXIoKS4xdDFzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjp+RklGT1NhbXBsZUJ1ZmZlcigpdTpzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjpyZWNlaXZlU2FtcGxlcyh1bnNpZ25lZCBpbnQpdkJzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjpyZWNlaXZlU2FtcGxlcyhmbG9hdCosIHVuc2lnbmVkIGludCl3NnNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXI6OnB1dFNhbXBsZXModW5zaWduZWQgaW50KXhEc291bmR0b3VjaDo6RklGT1NhbXBsZUJ1ZmZlcjo6cHV0U2FtcGxlcyhmbG9hdCBjb25zdCosIHVuc2lnbmVkIGludCl5KHNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXI6OnB0ckJlZ2luKCl6MHNvdW5kdG91Y2g6OkZJRk9TYW1wbGVCdWZmZXI6Om51bVNhbXBsZXMoKSBjb25zdHstc291bmR0b3VjaDo6RklGT1NhbXBsZUJ1ZmZlcjo6aXNFbXB0eSgpIGNvbnN0fCVzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjpjbGVhcigpfUFzb3VuZHRvdWNoOjpGSUZPU2FtcGxlQnVmZmVyOjphZGp1c3RBbW91bnRPZlNhbXBsZXModW5zaWduZWQgaW50KX43c291bmR0b3VjaDo6RklGT1Byb2Nlc3Nvcjo6cmVjZWl2ZVNhbXBsZXModW5zaWduZWQgaW50KX8/c291bmR0b3VjaDo6RklGT1Byb2Nlc3Nvcjo6cmVjZWl2ZVNhbXBsZXMoZmxvYXQqLCB1bnNpZ25lZCBpbnQpgAElc291bmR0b3VjaDo6RklGT1Byb2Nlc3Nvcjo6cHRyQmVnaW4oKYEBLXNvdW5kdG91Y2g6OkZJRk9Qcm9jZXNzb3I6Om51bVNhbXBsZXMoKSBjb25zdIIBKnNvdW5kdG91Y2g6OkZJRk9Qcm9jZXNzb3I6OmlzRW1wdHkoKSBjb25zdIMBPnNvdW5kdG91Y2g6OkZJRk9Qcm9jZXNzb3I6OmFkanVzdEFtb3VudE9mU2FtcGxlcyh1bnNpZ25lZCBpbnQphAEjc291bmR0b3VjaDo6QlBNRGV0ZWN0Ojp+QlBNRGV0ZWN0KCmFAaYBZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8dm9pZCAoU291bmRTdHJldGNoOjoqKShkb3VibGUpLCB2b2lkLCBTb3VuZFN0cmV0Y2gqLCBkb3VibGU+OjppbnZva2Uodm9pZCAoU291bmRTdHJldGNoOjoqIGNvbnN0JikoZG91YmxlKSwgU291bmRTdHJldGNoKiwgZG91YmxlKYYBigFlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjx2b2lkIChTb3VuZFN0cmV0Y2g6OiopKCksIHZvaWQsIFNvdW5kU3RyZXRjaCo+OjppbnZva2Uodm9pZCAoU291bmRTdHJldGNoOjoqIGNvbnN0JikoKSwgU291bmRTdHJldGNoKimHAZkCZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8dW5zaWduZWQgbG9uZyAoU291bmRTdHJldGNoOjoqKSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKSwgdW5zaWduZWQgbG9uZywgU291bmRTdHJldGNoKiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz46Omludm9rZSh1bnNpZ25lZCBsb25nIChTb3VuZFN0cmV0Y2g6OiogY29uc3QmKSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKSwgU291bmRTdHJldGNoKiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZymIAYsCZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8aW50IChCUE1EZXRlY3Rvcjo6KikodW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgaW50KSwgaW50LCBCUE1EZXRlY3RvciosIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcsIGludD46Omludm9rZShpbnQgKEJQTURldGVjdG9yOjoqIGNvbnN0JikodW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgaW50KSwgQlBNRGV0ZWN0b3IqLCB1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nLCBpbnQpiQGJAWVtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGZsb2F0IChCUE1EZXRlY3Rvcjo6KikoKSwgZmxvYXQsIEJQTURldGVjdG9yKj46Omludm9rZShmbG9hdCAoQlBNRGV0ZWN0b3I6OiogY29uc3QmKSgpLCBCUE1EZXRlY3RvciopigFJZW1zY3JpcHRlbjo6aW50ZXJuYWw6Okludm9rZXI8dW5zaWduZWQgbG9uZz46Omludm9rZSh1bnNpZ25lZCBsb25nICgqKSgpKYsBG19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5nc4wBEV9fd2FzbV9jYWxsX2N0b3JzjQENX19nZXRUeXBlTmFtZY4Bcl9fY3h4YWJpdjE6Ol9fc2lfY2xhc3NfdHlwZV9pbmZvOjpzZWFyY2hfYmVsb3dfZHN0KF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkIGNvbnN0KiwgaW50LCBib29sKSBjb25zdI8Bf19fY3h4YWJpdjE6Ol9fc2lfY2xhc3NfdHlwZV9pbmZvOjpzZWFyY2hfYWJvdmVfZHN0KF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkIGNvbnN0Kiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3SQAXFfX2N4eGFiaXYxOjpfX3NpX2NsYXNzX3R5cGVfaW5mbzo6aGFzX3VuYW1iaWd1b3VzX3B1YmxpY19iYXNlKF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkKiwgaW50KSBjb25zdJEBXV9fY3h4YWJpdjE6Ol9fcG9pbnRlcl90eXBlX2luZm86OmNhbl9jYXRjaChfX2N4eGFiaXYxOjpfX3NoaW1fdHlwZV9pbmZvIGNvbnN0Kiwgdm9pZComKSBjb25zdJIBYV9fY3h4YWJpdjE6Ol9fZnVuZGFtZW50YWxfdHlwZV9pbmZvOjpjYW5fY2F0Y2goX19jeHhhYml2MTo6X19zaGltX3R5cGVfaW5mbyBjb25zdCosIHZvaWQqJikgY29uc3STAW9fX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2JlbG93X2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3SUAXxfX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2Fib3ZlX2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIHZvaWQgY29uc3QqLCBpbnQsIGJvb2wpIGNvbnN0lQFuX19jeHhhYml2MTo6X19jbGFzc190eXBlX2luZm86Omhhc191bmFtYmlndW91c19wdWJsaWNfYmFzZShfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCosIGludCkgY29uc3SWAVtfX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6Y2FuX2NhdGNoKF9fY3h4YWJpdjE6Ol9fc2hpbV90eXBlX2luZm8gY29uc3QqLCB2b2lkKiYpIGNvbnN0lwEVX19jeGFfaXNfcG9pbnRlcl90eXBlmAEeU291bmRTdHJldGNoOjpzZXRUZW1wbyhkb3VibGUpmQEdU291bmRTdHJldGNoOjpzZXRSYXRlKGRvdWJsZSmaAR5Tb3VuZFN0cmV0Y2g6OnNldFBpdGNoKGRvdWJsZSmbASdTb3VuZFN0cmV0Y2g6OnNldFBpdGNoU2VtaVRvbmVzKGRvdWJsZSmcATBTb3VuZFN0cmV0Y2g6OnB1c2godW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZymdATBTb3VuZFN0cmV0Y2g6OnB1bGwodW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZymeARpTb3VuZFN0cmV0Y2g6OmdldFZlcnNpb24oKZ8BH1NvdW5kU3RyZXRjaDo6Z2V0Q2hhbm5lbENvdW50KCmgARVTb3VuZFN0cmV0Y2g6OmZsdXNoKCmhAR9Tb3VuZFN0cmV0Y2g6OmF2YWlsYWJsZSgpIGNvbnN0ogF+U291bmRTdHJldGNoKiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6b3BlcmF0b3JfbmV3PFNvdW5kU3RyZXRjaCwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz4odW5zaWduZWQgbG9uZyYmLCB1bnNpZ25lZCBsb25nJiYpowEtQlBNRGV0ZWN0b3I6OmlucHV0U2FtcGxlcyh1bnNpZ25lZCBsb25nLCBpbnQppAEVQlBNRGV0ZWN0b3I6OmdldEJwbSgppQE4QlBNRGV0ZWN0b3I6OmdldEJlYXRzKHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcsIGludCmmAVRCUE1EZXRlY3RvciogZW1zY3JpcHRlbjo6aW50ZXJuYWw6Om9wZXJhdG9yX25ldzxCUE1EZXRlY3RvciwgaW50LCBpbnQ+KGludCYmLCBpbnQmJikHEgEAD19fc3RhY2tfcG9pbnRlcgk9BgAHLnJvZGF0YQEJLnJvZGF0YS4xAgkucm9kYXRhLjIDCS5yb2RhdGEuMwQJLnJvZGF0YS40BQUuZGF0YQ==\";\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n    function getBinary(file) {\n      try {\n        if (file == wasmBinaryFile && wasmBinary) {\n          return new Uint8Array(wasmBinary);\n        }\n        var binary = tryParseAsDataURI(file);\n        if (binary) {\n          return binary;\n        }\n        if (readBinary) {\n          return readBinary(file);\n        }\n        throw \"both async and sync fetching of the wasm failed\";\n      } catch (err) {\n        abort(err);\n      }\n    }\n    function getBinaryPromise() {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n        if (typeof fetch == \"function\") {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            if (!response[\"ok\"]) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n            return response[\"arrayBuffer\"]();\n          })[\"catch\"](function () {\n            return getBinary(wasmBinaryFile);\n          });\n        }\n      }\n      return Promise.resolve().then(function () {\n        return getBinary(wasmBinaryFile);\n      });\n    }\n    function createWasm() {\n      var info = {\n        \"a\": asmLibraryArg\n      };\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module[\"asm\"] = exports;\n        wasmMemory = Module[\"asm\"][\"t\"];\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        wasmTable = Module[\"asm\"][\"y\"];\n        addOnInit(Module[\"asm\"][\"u\"]);\n        removeRunDependency(\"wasm-instantiate\");\n      }\n      addRunDependency(\"wasm-instantiate\");\n      function receiveInstantiationResult(result) {\n        receiveInstance(result[\"instance\"]);\n      }\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(function (instance) {\n          return instance;\n        }).then(receiver, function (reason) {\n          err(\"failed to asynchronously prepare wasm: \" + reason);\n          abort(reason);\n        });\n      }\n      function instantiateAsync() {\n        if (!wasmBinary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch == \"function\") {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiationResult, function (reason) {\n              err(\"wasm streaming compile failed: \" + reason);\n              err(\"falling back to ArrayBuffer instantiation\");\n              return instantiateArrayBuffer(receiveInstantiationResult);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(receiveInstantiationResult);\n        }\n      }\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n          return exports;\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \" + e);\n          readyPromiseReject(e);\n        }\n      }\n      instantiateAsync()[\"catch\"](readyPromiseReject);\n      return {};\n    }\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        callbacks.shift()(Module);\n      }\n    }\n    function intArrayToString(array) {\n      var ret = [];\n      for (var i = 0; i < array.length; i++) {\n        var chr = array[i];\n        if (chr > 255) {\n          if (ASSERTIONS) {\n            assert(false, \"Character code \" + chr + \" (\" + String.fromCharCode(chr) + \")  at offset \" + i + \" not in 0x00-0xFF.\");\n          }\n          chr &= 255;\n        }\n        ret.push(String.fromCharCode(chr));\n      }\n      return ret.join(\"\");\n    }\n    function ___assert_fail(condition, filename, line, func) {\n      abort(\"Assertion failed: \" + UTF8ToString(condition) + \", at: \" + [filename ? UTF8ToString(filename) : \"unknown filename\", line, func ? UTF8ToString(func) : \"unknown function\"]);\n    }\n    function ___cxa_allocate_exception(size) {\n      return _malloc(size + 24) + 24;\n    }\n    function ExceptionInfo(excPtr) {\n      this.excPtr = excPtr;\n      this.ptr = excPtr - 24;\n      this.set_type = function (type) {\n        HEAPU32[this.ptr + 4 >> 2] = type;\n      };\n      this.get_type = function () {\n        return HEAPU32[this.ptr + 4 >> 2];\n      };\n      this.set_destructor = function (destructor) {\n        HEAPU32[this.ptr + 8 >> 2] = destructor;\n      };\n      this.get_destructor = function () {\n        return HEAPU32[this.ptr + 8 >> 2];\n      };\n      this.set_refcount = function (refcount) {\n        HEAP32[this.ptr >> 2] = refcount;\n      };\n      this.set_caught = function (caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[this.ptr + 12 >> 0] = caught;\n      };\n      this.get_caught = function () {\n        return HEAP8[this.ptr + 12 >> 0] != 0;\n      };\n      this.set_rethrown = function (rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[this.ptr + 13 >> 0] = rethrown;\n      };\n      this.get_rethrown = function () {\n        return HEAP8[this.ptr + 13 >> 0] != 0;\n      };\n      this.init = function (type, destructor) {\n        this.set_adjusted_ptr(0);\n        this.set_type(type);\n        this.set_destructor(destructor);\n        this.set_refcount(0);\n        this.set_caught(false);\n        this.set_rethrown(false);\n      };\n      this.add_ref = function () {\n        var value = HEAP32[this.ptr >> 2];\n        HEAP32[this.ptr >> 2] = value + 1;\n      };\n      this.release_ref = function () {\n        var prev = HEAP32[this.ptr >> 2];\n        HEAP32[this.ptr >> 2] = prev - 1;\n        return prev === 1;\n      };\n      this.set_adjusted_ptr = function (adjustedPtr) {\n        HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n      };\n      this.get_adjusted_ptr = function () {\n        return HEAPU32[this.ptr + 16 >> 2];\n      };\n      this.get_exception_ptr = function () {\n        var isPointer = ___cxa_is_pointer_type(this.get_type());\n        if (isPointer) {\n          return HEAPU32[this.excPtr >> 2];\n        }\n        var adjusted = this.get_adjusted_ptr();\n        if (adjusted !== 0) return adjusted;\n        return this.excPtr;\n      };\n    }\n    var exceptionLast = 0;\n    var uncaughtExceptionCount = 0;\n    function ___cxa_throw(ptr, type, destructor) {\n      var info = new ExceptionInfo(ptr);\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw ptr;\n    }\n    function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\n    function getShiftFromSize(size) {\n      switch (size) {\n        case 1:\n          return 0;\n        case 2:\n          return 1;\n        case 4:\n          return 2;\n        case 8:\n          return 3;\n        default:\n          throw new TypeError(\"Unknown type size: \" + size);\n      }\n    }\n    function embind_init_charCodes() {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    }\n    var embind_charCodes = undefined;\n    function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n      while (HEAPU8[c]) {\n        ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    }\n    var awaitingDependencies = {};\n    var registeredTypes = {};\n    var typeDependencies = {};\n    var char_0 = 48;\n    var char_9 = 57;\n    function makeLegalFunctionName(name) {\n      if (undefined === name) {\n        return \"_unknown\";\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return \"_\" + name;\n      }\n      return name;\n    }\n    function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      return new Function(\"body\", \"return function \" + name + \"() {\\n\" + '    \"use strict\";' + \"    return body.apply(this, arguments);\\n\" + \"};\\n\")(body);\n    }\n    function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function (message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n        if (stack !== undefined) {\n          this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function () {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return this.name + \": \" + this.message;\n        }\n      };\n      return errorClass;\n    }\n    var BindingError = undefined;\n    function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n    var InternalError = undefined;\n    function throwInternalError(message) {\n      throw new InternalError(message);\n    }\n    function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n      myTypes.forEach(function (type) {\n        typeDependencies[type] = dependentTypes;\n      });\n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError(\"Mismatched type converter count\");\n        }\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach(function (dt, i) {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(function () {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    }\n    function registerType(rawType, registeredInstance) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!(\"argPackAdvance\" in registeredInstance)) {\n        throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n      }\n      var name = registeredInstance.name;\n      if (!rawType) {\n        throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n        }\n      }\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach(function (cb) {\n          return cb();\n        });\n      }\n    }\n    function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(wt) {\n          return !!wt;\n        },\n        \"toWireType\": function toWireType(destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": function readValueFromPointer(pointer) {\n          var heap;\n          if (size === 1) {\n            heap = HEAP8;\n          } else if (size === 2) {\n            heap = HEAP16;\n          } else if (size === 4) {\n            heap = HEAP32;\n          } else {\n            throw new TypeError(\"Unknown boolean type size: \" + name);\n          }\n          return this[\"fromWireType\"](heap[pointer >> shift]);\n        },\n        destructorFunction: null\n      });\n    }\n    function ClassHandle_isAliasOf(other) {\n      if (!(this instanceof ClassHandle)) {\n        return false;\n      }\n      if (!(other instanceof ClassHandle)) {\n        return false;\n      }\n      var leftClass = this.$$.ptrType.registeredClass;\n      var left = this.$$.ptr;\n      var rightClass = other.$$.ptrType.registeredClass;\n      var right = other.$$.ptr;\n      while (leftClass.baseClass) {\n        left = leftClass.upcast(left);\n        leftClass = leftClass.baseClass;\n      }\n      while (rightClass.baseClass) {\n        right = rightClass.upcast(right);\n        rightClass = rightClass.baseClass;\n      }\n      return leftClass === rightClass && left === right;\n    }\n    function shallowCopyInternalPointer(o) {\n      return {\n        count: o.count,\n        deleteScheduled: o.deleteScheduled,\n        preservePointerOnDelete: o.preservePointerOnDelete,\n        ptr: o.ptr,\n        ptrType: o.ptrType,\n        smartPtr: o.smartPtr,\n        smartPtrType: o.smartPtrType\n      };\n    }\n    function throwInstanceAlreadyDeleted(obj) {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n    }\n    var finalizationRegistry = false;\n    function detachFinalizer(handle) {}\n    function runDestructor($$) {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    }\n    function releaseClassHandle($$) {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n      if (toDelete) {\n        runDestructor($$);\n      }\n    }\n    function downcastPointer(ptr, ptrClass, desiredClass) {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n      if (undefined === desiredClass.baseClass) {\n        return null;\n      }\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n        return null;\n      }\n      return desiredClass.downcast(rv);\n    }\n    var registeredPointers = {};\n    function getInheritedInstanceCount() {\n      return Object.keys(registeredInstances).length;\n    }\n    function getLiveInheritedInstances() {\n      var rv = [];\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n      return rv;\n    }\n    var deletionQueue = [];\n    function flushPendingDeletes() {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj[\"delete\"]();\n      }\n    }\n    var delayFunction = undefined;\n    function setDelayFunction(fn) {\n      delayFunction = fn;\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    }\n    function init_embind() {\n      Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n      Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n      Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n      Module[\"setDelayFunction\"] = setDelayFunction;\n    }\n    var registeredInstances = {};\n    function getBasestPointer(class_, ptr) {\n      if (ptr === undefined) {\n        throwBindingError(\"ptr should not be undefined\");\n      }\n      while (class_.baseClass) {\n        ptr = class_.upcast(ptr);\n        class_ = class_.baseClass;\n      }\n      return ptr;\n    }\n    function getInheritedInstance(class_, ptr) {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    }\n    function makeClassHandle(prototype, record) {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n      }\n      record.count = {\n        value: 1\n      };\n      return attachFinalizer(Object.create(prototype, {\n        $$: {\n          value: record\n        }\n      }));\n    }\n    function RegisteredPointer_fromWireType(ptr) {\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (undefined !== registeredInstance) {\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance[\"clone\"]();\n        } else {\n          var rv = registeredInstance[\"clone\"]();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr: ptr\n          });\n        }\n      }\n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n      var toType;\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp\n        });\n      }\n    }\n    function attachFinalizer(handle) {\n      if (\"undefined\" === typeof FinalizationRegistry) {\n        attachFinalizer = function attachFinalizer(handle) {\n          return handle;\n        };\n        return handle;\n      }\n      finalizationRegistry = new FinalizationRegistry(function (info) {\n        releaseClassHandle(info.$$);\n      });\n      attachFinalizer = function attachFinalizer(handle) {\n        var $$ = handle.$$;\n        var hasSmartPtr = !!$$.smartPtr;\n        if (hasSmartPtr) {\n          var info = {\n            $$: $$\n          };\n          finalizationRegistry.register(handle, info, handle);\n        }\n        return handle;\n      };\n      detachFinalizer = function detachFinalizer(handle) {\n        return finalizationRegistry.unregister(handle);\n      };\n      return attachFinalizer(handle);\n    }\n    function ClassHandle_clone() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.preservePointerOnDelete) {\n        this.$$.count.value += 1;\n        return this;\n      } else {\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n          $$: {\n            value: shallowCopyInternalPointer(this.$$)\n          }\n        }));\n        clone.$$.count.value += 1;\n        clone.$$.deleteScheduled = false;\n        return clone;\n      }\n    }\n    function ClassHandle_delete() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n      detachFinalizer(this);\n      releaseClassHandle(this.$$);\n      if (!this.$$.preservePointerOnDelete) {\n        this.$$.smartPtr = undefined;\n        this.$$.ptr = undefined;\n      }\n    }\n    function ClassHandle_isDeleted() {\n      return !this.$$.ptr;\n    }\n    function ClassHandle_deleteLater() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n      deletionQueue.push(this);\n      if (deletionQueue.length === 1 && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n      this.$$.deleteScheduled = true;\n      return this;\n    }\n    function init_ClassHandle() {\n      ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n      ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n      ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n      ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n      ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n    }\n    function ClassHandle() {}\n    function ensureOverloadTable(proto, methodName, humanName) {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n        proto[methodName] = function () {\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n            throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n          }\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        };\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }\n    function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n        if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n        }\n        ensureOverloadTable(Module, name, name);\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n        }\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    }\n    function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n    function upcastPointer(ptr, ptrClass, desiredClass) {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n        }\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    }\n    function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      if (this.isSmartPointer) {\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n        }\n        switch (this.sharingPolicy) {\n          case 0:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n            }\n            break;\n          case 1:\n            ptr = handle.$$.smartPtr;\n            break;\n          case 2:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle[\"clone\"]();\n              ptr = this.rawShare(ptr, Emval.toHandle(function () {\n                clonedHandle[\"delete\"]();\n              }));\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n            break;\n          default:\n            throwBindingError(\"Unsupporting sharing policy\");\n        }\n      }\n      return ptr;\n    }\n    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function simpleReadValueFromPointer(pointer) {\n      return this[\"fromWireType\"](HEAP32[pointer >> 2]);\n    }\n    function RegisteredPointer_getPointee(ptr) {\n      if (this.rawGetPointee) {\n        ptr = this.rawGetPointee(ptr);\n      }\n      return ptr;\n    }\n    function RegisteredPointer_destructor(ptr) {\n      if (this.rawDestructor) {\n        this.rawDestructor(ptr);\n      }\n    }\n    function RegisteredPointer_deleteObject(handle) {\n      if (handle !== null) {\n        handle[\"delete\"]();\n      }\n    }\n    function init_RegisteredPointer() {\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n      RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n      RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n      RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n      RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n    }\n    function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this[\"toWireType\"] = genericPointerToWireType;\n      }\n    }\n    function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError(\"Replacing nonexistant public symbol\");\n      }\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    }\n    function dynCallLegacy(sig, ptr, args) {\n      var f = Module[\"dynCall_\" + sig];\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n    }\n    var wasmTableMirror = [];\n    function getWasmTableEntry(funcPtr) {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      return func;\n    }\n    function dynCall(sig, ptr, args) {\n      if (sig.includes(\"j\")) {\n        return dynCallLegacy(sig, ptr, args);\n      }\n      var rtn = getWasmTableEntry(ptr).apply(null, args);\n      return rtn;\n    }\n    function getDynCaller(sig, ptr) {\n      var argCache = [];\n      return function () {\n        argCache.length = 0;\n        Object.assign(argCache, arguments);\n        return dynCall(sig, ptr, argCache);\n      };\n    }\n    function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n      function makeDynCaller() {\n        if (signature.includes(\"j\")) {\n          return getDynCaller(signature, rawFunction);\n        }\n        return getWasmTableEntry(rawFunction);\n      }\n      var fp = makeDynCaller();\n      if (typeof fp != \"function\") {\n        throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n      }\n      return fp;\n    }\n    var UnboundTypeError = undefined;\n    function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    }\n    function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n      throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([\", \"]));\n    }\n    function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      if (upcast) {\n        upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n      if (downcast) {\n        downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n      exposePublicSymbol(legalFunctionName, function () {\n        throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [baseClassRawType]);\n      });\n      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) {\n        base = base[0];\n        var baseClass;\n        var basePrototype;\n        if (baseClassRawType) {\n          baseClass = base.registeredClass;\n          basePrototype = baseClass.instancePrototype;\n        } else {\n          basePrototype = ClassHandle.prototype;\n        }\n        var constructor = createNamedFunction(legalFunctionName, function () {\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\n            throw new BindingError(\"Use 'new' to construct \" + name);\n          }\n          if (undefined === registeredClass.constructor_body) {\n            throw new BindingError(name + \" has no accessible constructor\");\n          }\n          var body = registeredClass.constructor_body[arguments.length];\n          if (undefined === body) {\n            throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n          }\n          return body.apply(this, arguments);\n        });\n        var instancePrototype = Object.create(basePrototype, {\n          constructor: {\n            value: constructor\n          }\n        });\n        constructor.prototype = instancePrototype;\n        var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n        var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n        var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n        var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n        registeredPointers[rawType] = {\n          pointerType: pointerConverter,\n          constPointerType: constPointerConverter\n        };\n        replacePublicSymbol(legalFunctionName, constructor);\n        return [referenceConverter, pointerConverter, constPointerConverter];\n      });\n    }\n    function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError(\"new_ called with constructor type \" + _typeof(constructor) + \" which is not a function\");\n      }\n      var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function () {});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy();\n      var r = constructor.apply(obj, argumentList);\n      return r instanceof Object ? r : obj;\n    }\n    function runDestructors(destructors) {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    }\n    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n      var argCount = argTypes.length;\n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n      var needsDestructorStack = false;\n      for (var i = 1; i < argTypes.length; ++i) {\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n          needsDestructorStack = true;\n          break;\n        }\n      }\n      var returns = argTypes[0].name !== \"void\";\n      var argsList = \"\";\n      var argsListWired = \"\";\n      for (var i = 0; i < argCount - 2; ++i) {\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n        argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n      }\n      var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"var destructors = [];\\n\";\n      }\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n      if (isClassMethodFunc) {\n        invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n      }\n      for (var i = 0; i < argCount - 2; ++i) {\n        invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n        args1.push(\"argType\" + i);\n        args2.push(argTypes[i + 2]);\n      }\n      if (isClassMethodFunc) {\n        argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n      invokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n          var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n            args1.push(paramName + \"_dtor\");\n            args2.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n      if (returns) {\n        invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n      } else {}\n      invokerFnBody += \"}\\n\";\n      args1.push(invokerFnBody);\n      var invokerFunction = new_(Function, args1).apply(null, args2);\n      return invokerFunction;\n    }\n    function heap32VectorToArray(count, firstElement) {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n        array.push(HEAPU32[firstElement + i * 4 >> 2]);\n      }\n      return array;\n    }\n    function __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = classType.name + \".\" + methodName;\n        function unboundTypesHandler() {\n          throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n        }\n        if (methodName.startsWith(\"@@\")) {\n          methodName = Symbol[methodName.substring(2)];\n        }\n        var proto = classType.registeredClass.constructor;\n        if (undefined === proto[methodName]) {\n          unboundTypesHandler.argCount = argCount - 1;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;\n        }\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));\n          var func = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn);\n          if (undefined === proto[methodName].overloadTable) {\n            func.argCount = argCount - 1;\n            proto[methodName] = func;\n          } else {\n            proto[methodName].overloadTable[argCount - 1] = func;\n          }\n          return [];\n        });\n        return [];\n      });\n    }\n    function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n      assert(argCount > 0);\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = \"constructor \" + classType.name;\n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n        }\n        classType.registeredClass.constructor_body[argCount - 1] = function () {\n          throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n        };\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          argTypes.splice(1, 0, null);\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n          return [];\n        });\n        return [];\n      });\n    }\n    function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = classType.name + \".\" + methodName;\n        if (methodName.startsWith(\"@@\")) {\n          methodName = Symbol[methodName.substring(2)];\n        }\n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n        function unboundTypesHandler() {\n          throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n        }\n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n        if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n          if (undefined === proto[methodName].overloadTable) {\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n          return [];\n        });\n        return [];\n      });\n    }\n    var emval_free_list = [];\n    var emval_handle_array = [{}, {\n      value: undefined\n    }, {\n      value: null\n    }, {\n      value: true\n    }, {\n      value: false\n    }];\n    function __emval_decref(handle) {\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n        emval_handle_array[handle] = undefined;\n        emval_free_list.push(handle);\n      }\n    }\n    function count_emval_handles() {\n      var count = 0;\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          ++count;\n        }\n      }\n      return count;\n    }\n    function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          return emval_handle_array[i];\n        }\n      }\n      return null;\n    }\n    function init_emval() {\n      Module[\"count_emval_handles\"] = count_emval_handles;\n      Module[\"get_first_emval\"] = get_first_emval;\n    }\n    var Emval = {\n      toValue: function toValue(handle) {\n        if (!handle) {\n          throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n        }\n        return emval_handle_array[handle].value;\n      },\n      toHandle: function toHandle(value) {\n        switch (value) {\n          case undefined:\n            return 1;\n          case null:\n            return 2;\n          case true:\n            return 3;\n          case false:\n            return 4;\n          default:\n            {\n              var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n              emval_handle_array[handle] = {\n                refcount: 1,\n                value: value\n              };\n              return handle;\n            }\n        }\n      }\n    };\n    function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(handle) {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          return Emval.toHandle(value);\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: null\n      });\n    }\n    function embindRepr(v) {\n      if (v === null) {\n        return \"null\";\n      }\n      var t = _typeof(v);\n      if (t === \"object\" || t === \"array\" || t === \"function\") {\n        return v.toString();\n      } else {\n        return \"\" + v;\n      }\n    }\n    function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n        case 2:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n          };\n        case 3:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n          };\n        default:\n          throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }\n    function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          return value;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          return value;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n        destructorFunction: null\n      });\n    }\n    function integerReadValueFromPointer(name, shift, signed) {\n      switch (shift) {\n        case 0:\n          return signed ? function readS8FromPointer(pointer) {\n            return HEAP8[pointer];\n          } : function readU8FromPointer(pointer) {\n            return HEAPU8[pointer];\n          };\n        case 1:\n          return signed ? function readS16FromPointer(pointer) {\n            return HEAP16[pointer >> 1];\n          } : function readU16FromPointer(pointer) {\n            return HEAPU16[pointer >> 1];\n          };\n        case 2:\n          return signed ? function readS32FromPointer(pointer) {\n            return HEAP32[pointer >> 2];\n          } : function readU32FromPointer(pointer) {\n            return HEAPU32[pointer >> 2];\n          };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n    function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      name = readLatin1String(name);\n      if (maxRange === -1) {\n        maxRange = 4294967295;\n      }\n      var shift = getShiftFromSize(size);\n      var fromWireType = function fromWireType(value) {\n        return value;\n      };\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n        fromWireType = function fromWireType(value) {\n          return value << bitshift >>> bitshift;\n        };\n      }\n      var isUnsignedType = name.includes(\"unsigned\");\n      var checkAssertions = function checkAssertions(value, toTypeName) {};\n      var toWireType;\n      if (isUnsignedType) {\n        toWireType = function toWireType(destructors, value) {\n          checkAssertions(value, this.name);\n          return value >>> 0;\n        };\n      } else {\n        toWireType = function toWireType(destructors, value) {\n          checkAssertions(value, this.name);\n          return value;\n        };\n      }\n      registerType(primitiveType, {\n        name: name,\n        \"fromWireType\": fromWireType,\n        \"toWireType\": toWireType,\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n        destructorFunction: null\n      });\n    }\n    function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n      var TA = typeMapping[dataTypeIndex];\n      function decodeMemoryView(handle) {\n        handle = handle >> 2;\n        var heap = HEAPU32;\n        var size = heap[handle];\n        var data = heap[handle + 1];\n        return new TA(buffer, data, size);\n      }\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": decodeMemoryView,\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": decodeMemoryView\n      }, {\n        ignoreDuplicateRegistrations: true\n      });\n    }\n    function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      var stdStringIsUTF8 = name === \"std::string\";\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          var length = HEAPU32[value >> 2];\n          var payload = value + 4;\n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = payload;\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = payload + i;\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[payload + i]);\n            }\n            str = a.join(\"\");\n          }\n          _free(value);\n          return str;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var length;\n          var valueIsOfTypeString = typeof value == \"string\";\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError(\"Cannot pass non-string to std::string\");\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            length = lengthBytesUTF8(value);\n          } else {\n            length = value.length;\n          }\n          var base = _malloc(4 + length + 1);\n          var ptr = base + 4;\n          HEAPU32[base >> 2] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                }\n                HEAPU8[ptr + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + i] = value[i];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, base);\n          }\n          return base;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: function destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n    var UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n    function UTF16ToString(ptr, maxBytesToRead) {\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      while (!(idx >= maxIdx) && HEAPU16[idx]) {\n        ++idx;\n      }\n      endPtr = idx << 1;\n      if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      var str = \"\";\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n        var codeUnit = HEAP16[ptr + i * 2 >> 1];\n        if (codeUnit == 0) break;\n        str += String.fromCharCode(codeUnit);\n      }\n      return str;\n    }\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n    function UTF32ToString(ptr, maxBytesToRead) {\n      var i = 0;\n      var str = \"\";\n      while (!(i >= maxBytesToRead / 4)) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) break;\n        ++i;\n        if (utf32 >= 65536) {\n          var ch = utf32 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n      return str;\n    }\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n        }\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF32(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n        len += 4;\n      }\n      return len;\n    }\n    function __embind_register_std_wstring(rawType, charSize, name) {\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        getHeap = function getHeap() {\n          return HEAPU16;\n        };\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        getHeap = function getHeap() {\n          return HEAPU32;\n        };\n        shift = 2;\n      }\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          _free(value);\n          return str;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (!(typeof value == \"string\")) {\n            throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: function destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n    function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        name: name,\n        \"argPackAdvance\": 0,\n        \"fromWireType\": function fromWireType() {\n          return undefined;\n        },\n        \"toWireType\": function toWireType(destructors, o) {\n          return undefined;\n        }\n      });\n    }\n    function _abort() {\n      abort(\"\");\n    }\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.copyWithin(dest, src, src + num);\n    }\n    function getHeapMax() {\n      return 2147483648;\n    }\n    function emscripten_realloc_buffer(size) {\n      try {\n        wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1;\n      } catch (e) {}\n    }\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = HEAPU8.length;\n      requestedSize = requestedSize >>> 0;\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n      var alignUp = function alignUp(x, multiple) {\n        return x + (multiple - x % multiple) % multiple;\n      };\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n        var replacement = emscripten_realloc_buffer(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    }\n    embind_init_charCodes();\n    BindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n    InternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n    init_ClassHandle();\n    init_embind();\n    init_RegisteredPointer();\n    UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n    init_emval();\n    var ASSERTIONS = false;\n    var decodeBase64 = typeof atob == \"function\" ? atob : function (input) {\n      var keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var output = \"\";\n      var chr1, chr2, chr3;\n      var enc1, enc2, enc3, enc4;\n      var i = 0;\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n      do {\n        enc1 = keyStr.indexOf(input.charAt(i++));\n        enc2 = keyStr.indexOf(input.charAt(i++));\n        enc3 = keyStr.indexOf(input.charAt(i++));\n        enc4 = keyStr.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        output = output + String.fromCharCode(chr1);\n        if (enc3 !== 64) {\n          output = output + String.fromCharCode(chr2);\n        }\n        if (enc4 !== 64) {\n          output = output + String.fromCharCode(chr3);\n        }\n      } while (i < input.length);\n      return output;\n    };\n    function intArrayFromBase64(s) {\n      try {\n        var decoded = decodeBase64(s);\n        var bytes = new Uint8Array(decoded.length);\n        for (var i = 0; i < decoded.length; ++i) {\n          bytes[i] = decoded.charCodeAt(i);\n        }\n        return bytes;\n      } catch (_) {\n        throw new Error(\"Converting base64 string to bytes failed.\");\n      }\n    }\n    function tryParseAsDataURI(filename) {\n      if (!isDataURI(filename)) {\n        return;\n      }\n      return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n    }\n    var asmLibraryArg = {\n      \"a\": ___assert_fail,\n      \"f\": ___cxa_allocate_exception,\n      \"e\": ___cxa_throw,\n      \"m\": __embind_register_bigint,\n      \"s\": __embind_register_bool,\n      \"l\": __embind_register_class,\n      \"r\": __embind_register_class_class_function,\n      \"k\": __embind_register_class_constructor,\n      \"c\": __embind_register_class_function,\n      \"q\": __embind_register_emval,\n      \"j\": __embind_register_float,\n      \"d\": __embind_register_integer,\n      \"b\": __embind_register_memory_view,\n      \"i\": __embind_register_std_string,\n      \"h\": __embind_register_std_wstring,\n      \"p\": __embind_register_void,\n      \"o\": _abort,\n      \"n\": _emscripten_memcpy_big,\n      \"g\": _emscripten_resize_heap\n    };\n    var asm = createWasm();\n    var ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function () {\n      return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"u\"]).apply(null, arguments);\n    };\n    var ___getTypeName = Module[\"___getTypeName\"] = function () {\n      return (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"v\"]).apply(null, arguments);\n    };\n    var __embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = function () {\n      return (__embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = Module[\"asm\"][\"w\"]).apply(null, arguments);\n    };\n    var _malloc = Module[\"_malloc\"] = function () {\n      return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"x\"]).apply(null, arguments);\n    };\n    var _free = Module[\"_free\"] = function () {\n      return (_free = Module[\"_free\"] = Module[\"asm\"][\"z\"]).apply(null, arguments);\n    };\n    var ___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = function () {\n      return (___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = Module[\"asm\"][\"A\"]).apply(null, arguments);\n    };\n    var calledRun;\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n    function run(args) {\n      args = args || arguments_;\n      if (runDependencies > 0) {\n        return;\n      }\n      preRun();\n      if (runDependencies > 0) {\n        return;\n      }\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n    run();\n    return Module.ready;\n  };\n}();\nif (( false ? 0 : _typeof(exports)) === 'object' && ( false ? 0 : _typeof(module)) === 'object') module.exports = Module;else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  return Module;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n\n//# sourceURL=webpack://soundstretch-web/./wasm/build/soundtouch.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/worklet/bpm-count-processor.ts");
/******/ 	
/******/ })()
;